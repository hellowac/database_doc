<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据库相关的记录文档</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">简介</a></li><li class="spacer"></li><li class="chapter-item "><div>SQL</div></li><li class="chapter-item "><a href="mysql/index.html">MySQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mysql/introduction.html">简介</a></li></ol></li><li class="chapter-item "><a href="postgre/index.html">PostgreSQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="postgre/introduction.html">简介</a></li></ol></li><li class="chapter-item "><a href="clickhouse/index.html">ClickHouse</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/clickhouse-sqlalchemy.html">Clickhouse-SQLAlchemy</a></li><li class="chapter-item "><a href="clickhouse/clickhouse-driver.html">Clickhouse-driver</a></li><li class="chapter-item "><a href="clickhouse/connecti.html">连接数据库</a></li><li class="chapter-item "><a href="clickhouse/inner_tools.html">内置工具</a></li><li class="chapter-item "><a href="clickhouse/define_data.html">数据定义</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/define_data_base_type.html">基础数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/base_type_int.html">数值类型</a></li><li class="chapter-item "><a href="clickhouse/base_type_string.html">字符串类型</a></li><li class="chapter-item "><a href="clickhouse/base_type_datetime.html">时间类型</a></li></ol></li><li class="chapter-item "><a href="clickhouse/define_data_complex_type.html">复合数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/complex_type_array.html">数组</a></li><li class="chapter-item "><a href="clickhouse/complex_type_tuple.html">元组</a></li><li class="chapter-item "><a href="clickhouse/complex_type_enum.html">枚举</a></li><li class="chapter-item "><a href="clickhouse/complex_type_nested.html">嵌套</a></li></ol></li><li class="chapter-item "><a href="clickhouse/special_type.html">特殊类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/special_type_nullable.html">Nullable</a></li><li class="chapter-item "><a href="clickhouse/special_type_domain.html">Domain</a></li></ol></li></ol></li><li class="chapter-item "><a href="clickhouse/define_data_table_index.html">定义数据表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/define_database.html">数据库</a></li><li class="chapter-item "><a href="clickhouse/define_data_table.html">数据表</a></li><li class="chapter-item "><a href="clickhouse/define_field_default.html">字段默认值表达式</a></li><li class="chapter-item "><a href="clickhouse/define_temp_data_table.html">临时表</a></li><li class="chapter-item "><a href="clickhouse/define_partition_data_table.html">分区表</a></li><li class="chapter-item "><a href="clickhouse/define_view_data_table.html">视图</a></li></ol></li><li class="chapter-item "><div>表的操作</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>追加字段</div></li><li class="chapter-item "><div>修改数据类型</div></li><li class="chapter-item "><div>修改备注</div></li><li class="chapter-item "><div>删除已有字段</div></li><li class="chapter-item "><div>移动数据表</div></li><li class="chapter-item "><div>清空数据表</div></li></ol></li><li class="chapter-item "><div>数据分区操作</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>查询分区信息</div></li><li class="chapter-item "><div>删除指定分区</div></li><li class="chapter-item "><div>复制分区数据</div></li><li class="chapter-item "><div>重置分区数据</div></li><li class="chapter-item "><div>卸载与装载分区</div></li><li class="chapter-item "><div>备份与还原分区</div></li></ol></li><li class="chapter-item "><div>分布式DDL执行</div></li><li class="chapter-item "><div>数据的写入</div></li><li class="chapter-item "><div>数据的删除与修改</div></li></ol></li><li class="chapter-item "><a href="scripts/script_select_size.html">常用语句</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scripts/select_data_size.html">查询数据大小</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">数据库相关的记录文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>本文档主要记录与数据库相关的技术、技巧、问题等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">MySQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<p>官网：<a href="https://clickhouse.com/docs/en/">https://clickhouse.com/docs/en/</a></p>
<p>ClickHouse拥有完备的管理功能，所以它称得上是一个DBMS（Database Management System，数据库管理系统），而不仅是一个数据库。一些基本功能，如下所示：</p>
<ul>
<li><strong>DDL</strong>（数据定义语言）：可以动态地创建、修改或删除数据库、表和视图，而无须重启服务。</li>
<li><strong>DML</strong>（数据操作语言）：可以动态查询、插入、修改或删除数据。</li>
<li><strong>权限控制</strong>：可以按照用户粒度设置数据库或者表的操作权限，保障数据的安全性。</li>
<li><strong>数据备份与恢复</strong>：提供了数据备份导出与导入恢复机制，满足生产环境的要求。</li>
<li><strong>分布式管理</strong>：提供集群模式，能够自动管理多个数据库节点。</li>
</ul>
<p>ClickHouse就是一款使用<code>列式存储</code>的数据库，数据按列进行组织，属于同一列的数据会被保存在一起，列与列之间也会由不同的文件分别保存. 【主要针对<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/">MergeTree</a>引擎】</p>
<p>ClickHouse目前利用<code>SSE4.2指令集</code>实现向量化执行。</p>
<p>ClickHouse是大小写敏感的，这意味着<code>SELECT a</code>和<code>SELECT A</code>所代表的语义是不同的。</p>
<p>ClickHouse在数据存取方面，既支持分区（纵向扩展，利用多线程原理），也支持分片（横向扩展，利用分布式原理），ClickHouse将多线程和分布式的技术应用到了极致。</p>
<p>ClickHouse则采用<code>Multi-Master多主架构</code>，集群中的每个节点角色对等，客户端访问任意一个节点都能得到相同的效果。</p>
<p>ClickHouse支持分片，而分片则依赖集群。每个集群由1到多个分片组成，而每个分片则对应了ClickHouse的1个服务节点。分片的数量上限取决于节点数量（1个分片只能对应1个服务节点）。【数据分片是将数据进行横向切分，这是一种在面对海量数据的场景下，解决存储和查询瓶颈的有效手段，是一种分治思想的体现。】</p>
<p>ClickHouse提供了本地表（Local Table）与分布式表（Distributed Table）的概念。一张本地表等同于一份数据的分片。而分布式表本身不存储任何数据，它是本地表的访问代理，其作用类似分库中间件。借助分布式表，能够代理访问多个数据分片，从而实现分布式查询。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#clickhouse-sqlalchemy">Clickhouse-SQLAlchemy</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%AE%89%E8%A3%85">安装</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81">接口支持</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0">连接参数</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E9%A9%B1%E5%8A%A8%E9%80%89%E9%A1%B9">驱动选项</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%8A%9F%E8%83%BD">功能</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#sqlalchemy-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%94%AF%E6%8C%81">SQLAlchemy 声明式支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%9F%BA%E6%9C%AC%E7%9A%84ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E6%94%AF%E6%8C%81">基本的DDL(数据定义)支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%9F%BA%E6%9C%AC-insert-%E5%AD%90%E5%8F%A5%E6%94%AF%E6%8C%81">基本 INSERT 子句支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%B8%B8%E8%A7%81%E7%9A%84-sqlalchemy-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95">常见的 SQLAlchemy 链式查询方法</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E9%AB%98%E7%BA%A7-insert-%E5%AD%90%E5%8F%A5%E6%94%AF%E6%8C%81">高级 INSERT 子句支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E7%94%A8%E4%BA%8E%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E7%9A%84%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE">用于查询处理的外部数据</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E6%94%AF%E6%8C%81%E7%9A%84-clickhouse-%E7%89%B9%E5%88%AB%E7%9A%84-sql">支持的 ClickHouse 特别的 SQL</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE">覆盖默认查询设置</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">运行测试</a></li>
</ul>
</li>
</ul>
<h1 id="clickhouse-sqlalchemy"><a class="header" href="#clickhouse-sqlalchemy">Clickhouse-SQLAlchemy</a></h1>
<p>原文: <a href="https://github.com/xzkostyan/clickhouse-sqlalchemy/blob/master/README.rst">https://github.com/xzkostyan/clickhouse-sqlalchemy/blob/master/README.rst</a></p>
<p><strong>ClickHouse SQLAlchemy</strong> <a href="http://docs.sqlalchemy.org/en/latest/">SQLAlchemy</a>的连接Clickhouse数据库的方言版本。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>可以使用 pip 安装该软件包：</p>
<pre><code class="language-text">`pip install clickhouse-sqlalchemy`
</code></pre>
<h3 id="接口支持"><a class="header" href="#接口支持">接口支持</a></h3>
<ul>
<li>native 方式: 通过 <a href="https://github.com/mymarilyn/clickhouse-driver">clickhouse-driver</a> 【推荐】【TCP】</li>
<li>http 方式: 通过 <a href="https://2.python-requests.org/en/latest/">requests</a></li>
</ul>
<h2 id="连接参数"><a class="header" href="#连接参数">连接参数</a></h2>
<p>ClickHouse SQLAlchemy 使用下面的语法作为连接字符串:</p>
<pre><code class="language-text">'clickhouse+&lt;driver&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;[?key=value..]'
</code></pre>
<p>注意:</p>
<ul>
<li><em>driver</em> 是驱动选项. 可选: <code>http</code>, <code>native</code>. 默认为 <code>http</code>.</li>
<li><em>database</em> 是要连接的数据库. 默认为 <code>default</code>数据库.</li>
</ul>
<h3 id="驱动选项"><a class="header" href="#驱动选项">驱动选项</a></h3>
<p>可以在查询字符串中指定几个选项。</p>
<p><strong>HTTP</strong></p>
<ul>
<li><code>port</code> 是ClickHouse绑定的端口. 默认为 <code>8123</code>.</li>
<li><code>timeout</code> 以秒为单位的超时. 无默认值.</li>
<li><code>protocol</code> 要使用的协议. 可选: <code>http</code>, <code>https</code>. 默认为 <code>http</code>.</li>
</ul>
<p>安装ClickHouse后，默认的测试连接字符串是：</p>
<pre><code class="language-text">'clickhouse://default:@localhost/test'
</code></pre>
<p>当您使用 nginx 作为 ClickHouse 的代理服务器时，服务器连接字符串可能如下所示：</p>
<pre><code class="language-text">'clickhouse://user:password@example.com:8124/test?protocol=https'
</code></pre>
<p>这里的<code>8124</code>是代理端口。</p>
<p>如果您需要控制底层 HTTP 连接，请将 <a href="https://requests.readthedocs.io/en/master/user/advanced/#session-objects">requests.Session</a> 实例传递给 <code>create_engine()</code>，如下所示：</p>
<pre><code class="language-python">from sqlalchemy import create_engine
from requests import Session

uri = 'clickhouse://default:@localhost/test'

engine = create_engine(uri, connect_args={'http_session': Session()})
</code></pre>
<p><strong>Native</strong></p>
<p>请注意，<code>native</code>连接方式未加密。 包括用户/密码在内的所有数据都以纯文本形式传输。 通过不受信任的网络进行通信时，您应该通过 <code>SSH</code> 或 <code>VPN</code>（例如）使用此连接。</p>
<p>安装ClickHouse后，默认的测试连接字符串是：</p>
<pre><code class="language-text">'clickhouse+native://default:@localhost/test'
</code></pre>
<p>所有连接字符串参数都代理到 clickhouse-driver。 参考其<a href="https://clickhouse-driver.readthedocs.io/en/latest/api.html#clickhouse_driver.connection.Connection">parameters</a></p>
<h2 id="功能"><a class="header" href="#功能">功能</a></h2>
<h3 id="sqlalchemy-声明式支持"><a class="header" href="#sqlalchemy-声明式支持">SQLAlchemy 声明式支持</a></h3>
<p>ORM声明式和构造表的函数式两种方式都支持：</p>
<pre><code class="language-python">from sqlalchemy import create_engine, Column, MetaData, literal

from clickhouse_sqlalchemy import Table, make_session, get_declarative_base, types, engines

uri = 'clickhouse://default:@localhost/test'

engine = create_engine(uri)
session = make_session(engine)
metadata = MetaData(bind=engine)

Base = get_declarative_base(metadata=metadata)

class Rate(Base):
    day = Column(types.Date, primary_key=True)
    value = Column(types.Int32)
    other_value = Column(
        types.DateTime,
        clickhouse_codec=('DoubleDelta', 'ZSTD'),
    )

    __table_args__ = (
        engines.Memory(),
    )

another_table = Table('another_rate', metadata,
    Column('day', types.Date, primary_key=True),
    Column('value', types.Int32, server_default=literal(1)),
    engines.Memory()
)
</code></pre>
<p>以声明方式创建的表名具有小写字母，单词由下划线命名约定分隔。 但是您可以通过 SQLAlchemy 的 <code>__tablename__</code> 属性轻松设置您自己的表名。</p>
<h3 id="基本的ddl数据定义支持"><a class="header" href="#基本的ddl数据定义支持">基本的DDL(数据定义)支持</a></h3>
<p>您可以发出简单的 DDL。 例如 CREATE/DROP 表：</p>
<pre><code class="language-python">table = Rate.__table__
table.create()
another_table.create()


another_table.drop()
table.drop()
</code></pre>
<h3 id="基本-insert-子句支持"><a class="header" href="#基本-insert-子句支持">基本 INSERT 子句支持</a></h3>
<p>简单的批量插入：</p>
<pre><code class="language-python">from datetime import date, timedelta
from sqlalchemy import func

today = date.today()
rates = [{'day': today - timedelta(i), 'value': 200 - i} for i in range(100)]

# Emits single INSERT statement.
session.execute(table.insert(), rates)
</code></pre>
<h3 id="常见的-sqlalchemy-链式查询方法"><a class="header" href="#常见的-sqlalchemy-链式查询方法">常见的 SQLAlchemy 链式查询方法</a></h3>
<p><code>order_by</code>, <code>filter</code>, <code>limit</code>, <code>offset</code>等都是支持的：</p>
<pre><code class="language-python">session.query(func.count(Rate.day)) \
    .filter(Rate.day &gt; today - timedelta(20)) \
    .scalar()

session.query(Rate.value) \
    .order_by(Rate.day.desc()) \
    .first()

session.query(Rate.value) \
    .order_by(Rate.day) \
    .limit(10) \
    .all()

session.query(func.sum(Rate.value)) \
    .scalar()
</code></pre>
<h3 id="高级-insert-子句支持"><a class="header" href="#高级-insert-子句支持">高级 INSERT 子句支持</a></h3>
<p>INSERT FROM SELECT 语句:</p>
<pre><code class="language-python">from sqlalchemy import cast

# Labels must be present.
select_query = session.query(
    Rate.day.label('day'),
    cast(Rate.value * 1.5, types.Int32).label('value')
).subquery()

# Emits single INSERT FROM SELECT statement
session.execute(
    another_table.insert()
    .from_select(['day', 'value'], select_query)
)
</code></pre>
<p>许多但不是所有的 SQLAlchemy 特性都支持开箱即用。</p>
<p>UNION ALL 示例：</p>
<pre><code class="language-python">from sqlalchemy import union_all

select_rate = session.query(
    Rate.day.label('date'),
    Rate.value.label('x')
)
select_another_rate = session.query(
    another_table.c.day.label('date'),
    another_table.c.value.label('x')
)

union_all(select_rate, select_another_rate).execute().fetchone()
</code></pre>
<h3 id="用于查询处理的外部数据"><a class="header" href="#用于查询处理的外部数据">用于查询处理的外部数据</a></h3>
<p>目前可以与native方式的接口一起使用:</p>
<pre><code class="language-python">ext = Table(
    'ext', metadata, Column('x', types.Int32),
    clickhouse_data=[(101, ), (103, ), (105, )], extend_existing=True
)

rv = session.query(Rate) \
    .filter(Rate.value.in_(session.query(ext.c.x))) \
    .execution_options(external_tables=[ext]) \
    .all()

print(rv)
</code></pre>
<h3 id="支持的-clickhouse-特别的-sql"><a class="header" href="#支持的-clickhouse-特别的-sql">支持的 ClickHouse 特别的 SQL</a></h3>
<ul>
<li><strong>SELECT query</strong>:
<ul>
<li><strong>WITH TOTALS</strong></li>
<li><strong>SAMPLE</strong></li>
<li><strong>lambda functions: x -&gt; expr</strong></li>
<li><strong>JOIN</strong></li>
</ul>
</li>
</ul>
<p>示例请参考 <a href="https://github.com/xzkostyan/clickhouse-sqlalchemy/tree/master/tests">tests</a></p>
<h2 id="覆盖默认查询设置"><a class="header" href="#覆盖默认查询设置">覆盖默认查询设置</a></h2>
<p>设置较低的查询优先级并限制执行请求的最大线程数。</p>
<pre><code class="language-python">rv = session.query(func.sum(Rate.value)) \
    .execution_options(settings={'max_threads': 2, 'priority': 10}) \
    .scalar()

print(rv)
</code></pre>
<h2 id="运行测试"><a class="header" href="#运行测试">运行测试</a></h2>
<pre><code class="language-shell">mkvirtualenv testenv &amp;&amp; python setup.py test
</code></pre>
<p><code>pip</code> 将自动安装所有必需的模块进行测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse-driver"><a class="header" href="#clickhouse-driver">Clickhouse-driver</a></h1>
<p>原文: <a href="https://github.com/mymarilyn/clickhouse-driver/blob/master/README.rst">https://github.com/mymarilyn/clickhouse-driver/blob/master/README.rst</a></p>
<p>具有Native (TCP) 接口支持的 ClickHouse Python 驱动程序。</p>
<p>异步包装器可用在: <a href="https://github.com/mymarilyn/aioch">https://github.com/mymarilyn/aioch</a></p>
<h2 id="功能-1"><a class="header" href="#功能-1">功能</a></h2>
<ul>
<li>基于外部数据的查询处理支持.</li>
<li>Query查询设置.</li>
<li>压缩支持.</li>
<li>TLS 支持.</li>
<li>类型支持:
<ul>
<li>Float32/64</li>
<li>[U]Int8/16/32/64/128/256</li>
<li>Date/Date32/DateTime('timezone')/DateTime64('timezone')</li>
<li>String/FixedString(N)</li>
<li>Enum8/16</li>
<li>Array(T)</li>
<li>Nullable(T)</li>
<li>Bool</li>
<li>UUID</li>
<li>Decimal</li>
<li>IPv4/IPv6</li>
<li>LowCardinality(T)</li>
<li>SimpleAggregateFunction(F, T)</li>
<li>Tuple(T1, T2, ...)</li>
<li>Nested</li>
<li>Map(key, value)</li>
</ul>
</li>
<li>Query查询进度信息。</li>
<li>基于Block块式的结果流传输.</li>
<li>读取查询配置文件信息.</li>
<li>接收服务器日志.</li>
<li>多主机支持.</li>
<li>Python DB API 2.0 规范支持.</li>
<li>可选的 NumPy 数组支持.</li>
</ul>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<p>文档可在 <a href="https://clickhouse-driver.readthedocs.io">https://clickhouse-driver.readthedocs.io</a> 获得。</p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>与服务器通信有两种方式：</p>
<ol>
<li>使用纯客户端；</li>
<li>使用数据库 API。</li>
</ol>
<p><strong>纯客户端</strong> 示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from clickhouse_driver import Client
&gt;&gt;&gt;
&gt;&gt;&gt; client = Client('localhost')
&gt;&gt;&gt;
&gt;&gt;&gt; client.execute('SHOW TABLES')
[('test',)]
&gt;&gt;&gt; client.execute('DROP TABLE IF EXISTS test')
[]
&gt;&gt;&gt; client.execute('CREATE TABLE test (x Int32) ENGINE = Memory')
[]
&gt;&gt;&gt; client.execute(
...     'INSERT INTO test (x) VALUES',
...     [{'x': 100}]
... )
1
&gt;&gt;&gt; client.execute('INSERT INTO test (x) VALUES', [[200]])
1
&gt;&gt;&gt; client.execute(
...     'INSERT INTO test (x) '
...     'SELECT * FROM system.numbers LIMIT %(limit)s',
...     {'limit': 3}
... )
[]
&gt;&gt;&gt; client.execute('SELECT sum(x) FROM test')
[(303,)]
</code></pre>
<p><strong>数据库API</strong> 示例:</p>
<pre><code class="language-python">&gt;&gt;&gt; from clickhouse_driver import connect
&gt;&gt;&gt;
&gt;&gt;&gt; conn = connect('clickhouse://localhost')
&gt;&gt;&gt; cursor = conn.cursor()
&gt;&gt;&gt;
&gt;&gt;&gt; cursor.execute('SHOW TABLES')
&gt;&gt;&gt; cursor.fetchall()
[('test',)]
&gt;&gt;&gt; cursor.execute('DROP TABLE IF EXISTS test')
&gt;&gt;&gt; cursor.fetchall()
[]
&gt;&gt;&gt; cursor.execute('CREATE TABLE test (x Int32) ENGINE = Memory')
&gt;&gt;&gt; cursor.fetchall()
[]
&gt;&gt;&gt; cursor.executemany(
...     'INSERT INTO test (x) VALUES',
...     [{'x': 100}]
... )
&gt;&gt;&gt; cursor.rowcount
1
&gt;&gt;&gt; cursor.executemany('INSERT INTO test (x) VALUES', [[200]])
&gt;&gt;&gt; cursor.rowcount
1
&gt;&gt;&gt; cursor.execute(
...     'INSERT INTO test (x) '
...     'SELECT * FROM system.numbers LIMIT %(limit)s',
...     {'limit': 3}
... )
&gt;&gt;&gt; cursor.rowcount
0
&gt;&gt;&gt; cursor.execute('SELECT sum(x) FROM test')
&gt;&gt;&gt; cursor.fetchall()
[(303,)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连接数据库"><a class="header" href="#连接数据库">连接数据库</a></h1>
<pre><code class="language-shell">&gt; clickhouse-client -h host -p port
</code></pre>
<p><strong>常见参数:</strong></p>
<ul>
<li>
<p>--host/-h：服务端的地址，默认值为localhost。</p>
<pre><code class="language-shell">&gt; clickhouse-client -h 10.37.129.10
</code></pre>
</li>
<li>
<p>--port：服务端的TCP端口，默认值为9000。</p>
</li>
<li>
<p>--user/-u：登录的用户名，默认值为default。</p>
</li>
<li>
<p>--password：登录的密码，默认值为空。</p>
</li>
<li>
<p>--database/-d：登录的数据库，默认值为default。</p>
</li>
<li>
<p>--query/-q：只能在非交互式查询时使用，用于指定SQL语句。</p>
</li>
<li>
<p>--multiquery/-n：在非交互式执行时，允许一次运行多条SQL语句，多条语句之间以分号间隔。</p>
</li>
<li>
<p>--time/-t：在非交互式执行时，会打印每条SQL的执行时间，例如</p>
<pre><code class="language-shell">&gt; clickhouse-client -h 10.37.129.10 -n -t --query=&quot;SELECT 1;SELECT 2;&quot;
1
0.002
2
0.001
</code></pre>
</li>
<li>
<p>完整的参数列表，可以通过--help查阅。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置工具"><a class="header" href="#内置工具">内置工具</a></h1>
<h2 id="clickhouse-local"><a class="header" href="#clickhouse-local">clickhouse-local</a></h2>
<p>clickhouse-local可以独立运行大部分SQL查询，不需要依赖任何ClickHouse的服务端程序，它可以理解成是ClickHouse服务的单机版微内核，是一个轻量级的应用程序。</p>
<p>clickhouse-local只能够使用File表引擎（关于表引擎的更多介绍在后续章节展开），它的数据与同机运行的ClickHouse服务也是完全隔离的，相互之间并不能访问。</p>
<p>clickhouse-local是非交互式运行的，每次执行都需要指定数据来源，例如通过stdin标准输入，以echo打印作为数据来源：</p>
<pre><code class="language-shell">&gt; echo -e &quot;1\n2\n3&quot; | clickhouse-local -q &quot;CREATE TABLE test_table (id Int64)  ENGINE = File(CSV, stdin); SELECT id FROM test_table;&quot;
1
2
3
</code></pre>
<p>也可以借助操作系统的命令，实现对系统用户内存用量的查询：</p>
<pre><code class="language-shell">&gt; ps aux | tail -n +2 | awk '{ printf(&quot;%s\t%s\n&quot;, $1, $4) }' | clickhouse-local -S &quot;user String, memory Float64&quot; -q &quot;SELECT user, round(sum(memory), 2) as memoryTotal FROM table GROUP BY user ORDER BY memoryTotal DESC FORMAT Pretty&quot;
┏----------┳-----------------------------┓
┃ user     ┃        memoryTotal          ┃
┡----------╇-----------------------------┩
│ nauu     │        42.7                 │
├──────────┼──────────----------------───┤
│ root     │        20.4                 │
├──────────┼─────────----------------────┤
│ clickho+ │         1.8                 │
└──────────┴────────----------------─────┘
</code></pre>
<p><strong>核心参数</strong>：</p>
<ul>
<li>
<p>（1）-S/--structure：表结构的简写方式，例如以下两种声明的效果是相同的。</p>
<pre><code class="language-shell">--使用-S简写
clickhouse-local -S &quot;id Int64&quot;
--使用DDL
clickhouse-local -q &quot;CREATE TABLE test_table (id Int64) ENGINE = File(CSV, stdin)&quot;
</code></pre>
</li>
<li>
<p>（2）-N/--table：表名称，默认值是table，例如下面的代码。</p>
<pre><code class="language-shell">clickhouse-local -S &quot;id Int64&quot; -N &quot;test_table&quot; -q &quot;SELECt id FROM test_table&quot;
</code></pre>
</li>
<li>
<p>（3）-if/--input-format：输入数据的格式，默认值是TSV，例如下面的代码。</p>
<pre><code class="language-shell">echo -e &quot;1\n2\n3&quot; | clickhouse-local -S &quot;id Int64&quot; -if &quot;CSV&quot; -N &quot;test_table&quot;
</code></pre>
</li>
<li>
<p>（4）-f/--file：输入数据的地址，默认值是stdin标准输入。</p>
</li>
<li>
<p>（5）-q/--query：待执行的SQL语句，多条语句之间以分号间隔。</p>
</li>
</ul>
<p>完整的参数列表可以通过--help查阅。</p>
<h2 id="clickhouse-benchmark"><a class="header" href="#clickhouse-benchmark">clickhouse-benchmark</a></h2>
<p>clickhouse-benchmark是基准测试的小工具，它可以自动运行SQL查询，并生成相应的运行指标报告，例如执行下面的语句启动测试：</p>
<pre><code class="language-shell">&gt; echo &quot;SELECT * FROM system.numbers LIMIT 100&quot; | clickhouse-benchmark -i 5
Loaded 1 queries.

# 执行之后，按照指定的参数该查询会执行5次：
Queries executed: 5.  

# 执行完毕后，会出具包含QPS、RPS等指标信息的报告：
127.0.0.1:9000, queries 5, QPS: 812.189, RPS: 81218.868, MiB/s: 0.620, result RPS: 81218.868, result MiB/s: 0.620.

# 还会出具各百分位的查询执行时间：
0.000%          0.001 sec.
10.000%         0.001 sec.
20.000%         0.001 sec.
30.000%         0.001 sec.
40.000%         0.001 sec.
50.000%         0.001 sec.
60.000%         0.001 sec.
70.000%         0.001 sec.
80.000%         0.001 sec.
90.000%         0.002 sec.
95.000%         0.002 sec.
99.000%         0.002 sec.
99.900%         0.002 sec.
99.990%         0.002 sec.

# 可以指定多条SQL进行测试，此时需要将SQL语句定义在文件中：
&gt; cat ./multi-sqls 
SELECT * FROM system.numbers LIMIT 100
SELECT * FROM system.numbers LIMIT 200

# 在multi-sqls文件内定义了两条SQL，按照定义的顺序它们会依次执行：
&gt; clickhouse-benchmark -i 5 &lt; ./multi-sqls
Loaded 2 queries.
……
</code></pre>
<p><strong>核心参数</strong>:</p>
<ul>
<li>
<p>（1）-i/--iterations：SQL查询执行的次数，默认值是0。</p>
</li>
<li>
<p>（2）-c/--concurrency：同时执行查询的并发数，默认值是1。</p>
</li>
<li>
<p>（3）-r/--randomize：在执行多条SQL语句的时候，按照随机顺序执行，例如:</p>
<pre><code class="language-shell">&gt; clickhouse-benchmark -r 1 -i 5  &lt; ./multi-sqls
</code></pre>
</li>
<li>
<p>（4）-h/--host：服务端地址，默认值是localhost。clickhouse-benchmark支持对比测试，此时需要通过此参数声明两个服务端的地址，例如:</p>
<pre><code class="language-shell">&gt; echo &quot;SELECT * FROM system.numbers LIMIT 100&quot; | clickhouse-benchmark -i 5 -h localhost -h localhost
Loaded 1 queries.

Queries executed: 5.

# 第一个服务
127.0.0.1:9000, queries 2, QPS: 878.703, RPS: 87870.258, MiB/s: 0.670, result RPS: 87870.258, result MiB/s: 0.670.
# 第二个服务
127.0.0.1:9000, queries 3, QPS: 748.210, RPS: 74820.972, MiB/s: 0.571, result RPS: 74820.972, result MiB/s: 0.571.

# 在对比测试中，clickhouse-benchmark会通过抽样的方式比较两组查询指标的差距，在默认的情况下，置信区间为99.5%：
0.000%          0.001 sec.      0.001 sec.
10.000%         0.001 sec.      0.001 sec.
20.000%         0.001 sec.      0.001 sec.
30.000%         0.001 sec.      0.001 sec.
40.000%         0.001 sec.      0.001 sec.
50.000%         0.001 sec.      0.001 sec.
60.000%         0.001 sec.      0.001 sec.
70.000%         0.001 sec.      0.001 sec.
80.000%         0.001 sec.      0.002 sec.
90.000%         0.001 sec.      0.002 sec.
95.000%         0.001 sec.      0.002 sec.
99.000%         0.001 sec.      0.002 sec.
99.900%         0.001 sec.      0.002 sec.
99.990%         0.001 sec.      0.002 sec.

No difference proven at 99.5% confidence
</code></pre>
</li>
<li>
<p>（5）--confidence：设置对比测试中置信区间的范围，默认值是5(99.5%)，它的取值范围有0(80%)、1(90%)、2(95%)、3(98%)、4(99%)和5(99.5%)。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据定义"><a class="header" href="#数据定义">数据定义</a></h1>
<p>ClickHouse提供了许多数据类型，它们可以划分为基础类型、复合类型和特殊类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础数据类型"><a class="header" href="#基础数据类型">基础数据类型</a></h1>
<p>基础类型只有<code>数值</code>、<code>字符串</code>和<code>时间</code>三种类型，没有<code>Boolean</code>类型，但可以使用整型的<code>0</code>或<code>1</code>替代。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_int.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>
<ul>
<li><a href="clickhouse/base_type_int.html#int">Int</a></li>
<li><a href="clickhouse/base_type_int.html#float">Float</a></li>
<li><a href="clickhouse/base_type_int.html#decimal">Decimal</a></li>
</ul>
</li>
</ul>
<h1 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h1>
<p>数值类型分为<code>整数</code>、<code>浮点数</code>和<code>定点数</code>三类.</p>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/int-uint/">https://clickhouse.com/docs/zh/sql-reference/data-types/int-uint/</a></p>
<p>创建表时，可以为整数设置类型参数 (例如. TINYINT(8), SMALLINT(16), INT(32), BIGINT(64)), 但 ClickHouse 会忽略它们.</p>
<p>有符号</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>范围</th><th>常用</th></tr></thead><tbody>
<tr><td>Int8</td><td>1</td><td>-128 - 127</td><td>Tinyint</td></tr>
<tr><td>Int16</td><td>2</td><td>-32768 - 32767</td><td>Smallint</td></tr>
<tr><td>Int32</td><td>4</td><td>-2147483648 - 2147483647</td><td>Int</td></tr>
<tr><td>Int64</td><td>8</td><td>-9223372036854775808 - 9223372036854775807</td><td>Bigint</td></tr>
<tr><td>Int128</td><td>16</td><td>-1701411834604692317... - 1701411834604692317...</td><td>-</td></tr>
<tr><td>Int256</td><td>32</td><td>-5789604461865809771... - 5789604461865809771...</td><td>-</td></tr>
</tbody></table>
<p>无符号</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>范围</th><th>常用</th></tr></thead><tbody>
<tr><td>UInt8</td><td>1</td><td>0 - 255</td><td>Tinyint Unsigned</td></tr>
<tr><td>UInt16</td><td>2</td><td>0 - 65535</td><td>Smallint Unsigned</td></tr>
<tr><td>UInt32</td><td>4</td><td>0 - 4294967295</td><td>Int Unsigned</td></tr>
<tr><td>UInt64</td><td>8</td><td>0 - 18446744073709551615</td><td>Bigint Unsigned</td></tr>
<tr><td>UInt128</td><td>16</td><td>0 - 340282366920938463463374607431768211455</td><td>-</td></tr>
<tr><td>UInt256</td><td>32</td><td>0 - 115792089237316195423570985008687907853...</td><td>-</td></tr>
</tbody></table>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/float/">https://clickhouse.com/docs/zh/sql-reference/data-types/float/</a></p>
<p>与整数类似，ClickHouse直接使用<code>Float32</code>和<code>Float64</code>代表单精度浮点数以及双精度浮点数</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>有效经度(位数)</th><th>常用</th></tr></thead><tbody>
<tr><td>Float32</td><td>4</td><td>7</td><td>Float</td></tr>
<tr><td>Float64</td><td>8</td><td>16</td><td>Double</td></tr>
</tbody></table>
<p>ClickHouse的浮点数支持正无穷、负无穷以及非数字的表达方式。</p>
<ul>
<li>
<p>Inf – 正无穷</p>
<pre><code class="language-sql">&gt;) SELECT 0.5 / 0
┌─divide(0.5, 0)─┐
│            inf │
└────────────────┘
</code></pre>
</li>
<li>
<p>-Inf – 负无穷</p>
<pre><code class="language-sql">&gt;) SELECT -0.5 / 0
┌─divide(-0.5, 0)─┐
│            -inf │
└─────────────────┘
</code></pre>
</li>
<li>
<p>NaN – 非数字</p>
<pre><code class="language-sql">&gt;) SELECT 0 / 0
┌─divide(0, 0)──┐
│            nan│
└───────────────┘
</code></pre>
</li>
</ul>
<h2 id="decimal"><a class="header" href="#decimal">Decimal</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/decimal/">https://clickhouse.com/docs/zh/sql-reference/data-types/decimal/</a></p>
<p>更高精度的数值运算，则需要使用定点数。ClickHouse提供了Decimal32、Decimal64和Decimal128三种精度的定点数。可以通过两种形式声明定点：简写方式有Decimal32(S)、Decimal64(S)、Decimal128(S)三种，原生方式为Decimal(P,S)，其中：</p>
<ul>
<li>P代表精度，决定总位数（整数部分+小数部分），取值范围是1～38；</li>
<li>S代表规模，决定小数位数，取值范围是0～P。</li>
</ul>
<p>对应关系：</p>
<table><thead><tr><th>名称</th><th>有效声明</th><th>范围</th></tr></thead><tbody>
<tr><td>Decimal32(S)</td><td>Decimal(1 ~ 9 , S)</td><td>-1 * 10<sup>^</sup>(9-S) 至  10<sup>^</sup>(9-S)</td></tr>
<tr><td>Decimal64(S)</td><td>Decimal(10 ~ 18 , S)</td><td>-1 * 10<sup>^</sup>(18-S) 至  10<sup>^</sup>(18-S)</td></tr>
<tr><td>Decimal128(S)</td><td>Decimal(19 ~ 38 , S)</td><td>-1 * 10<sup>^</sup>(38-S) 至  10<sup>^</sup>(38-S)</td></tr>
</tbody></table>
<p>由于现代CPU不支持128位数字，因此 <code>Decimal128</code> 上的操作由软件模拟。所以 <code>Decimal128</code> 的运算速度明显慢于 <code>Decimal32</code>/<code>Decimal64</code>。</p>
<p><strong>对Decimal的二进制运算导致更宽的结果类型（无论参数的顺序如何）。</strong></p>
<ul>
<li>Decimal64(S1) &lt;op&gt; Decimal32(S2) -&gt; Decimal64(S)</li>
<li>Decimal128(S1) &lt;op&gt; Decimal32(S2) -&gt; Decimal128(S)</li>
<li>Decimal128(S1) &lt;op&gt; Decimal64(S2) -&gt; Decimal128(S)</li>
</ul>
<p><strong>精度变化的规则：</strong></p>
<ul>
<li>加法，减法：S = max(S1, S2)。</li>
<li>乘法：S = S1 + S2。</li>
<li>除法：S = S1。</li>
</ul>
<p>例如<code>toDecimal64(2,4)</code>与<code>toDecimal32(2,2)</code>相加或相减后<code>S=4</code>：</p>
<pre><code class="language-shell"># 相加
:) SELECT toDecimal64(2,4) + toDecimal32(2,2)
 
┌─plus(toDecimal64(2, 4), toDecimal32(2, 2))─┐
│ 4.0000                                     │ # 保留四位
└────────────────────────────────────────────┘

# 相减
:) SELECT toDecimal32(4,4) - toDecimal64(2,2)

┌─minus(toDecimal32(4, 4), toDecimal64(2, 2))┐
│ 2.0000                                     │ # 保留四位
└────────────────────────────────────────────┘

# toDecimal64(2,4)与toDecimal32(2,2)相乘后S=4+2=6
:) SELECT toDecimal64(2,4) * toDecimal32(2,2)

┌─multiply(toDecimal64(2, 4), toDecimal32(2, 2))┐
│ 4.000000                                      │
└───────────────────────────────────────────────┘

# toDecimal64(2,4)与toDecimal32(2,2)相除后S=4
:) SELECT toDecimal64(2,4) / toDecimal32(2,2)

┌─divide(toDecimal64(2, 4), toDecimal32(2, 2))─┐
│  1.0000                                      │
└──────────────────────────────────────────────┘

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">字符串类型</a>
<ul>
<li><a href="clickhouse/base_type_string.html#string">String</a></li>
<li><a href="clickhouse/base_type_string.html#fixedstring">FixedString</a></li>
<li><a href="clickhouse/base_type_string.html#uuid">UUID</a></li>
</ul>
</li>
</ul>
<h1 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h1>
<p>字符串类型可以细分为<code>String</code>、<code>FixedString</code>和<code>UUID</code>三类</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>字符串由String定义，长度不限。因此在使用String的时候无须声明大小。它完全代替了传统意义上数据库的Varchar、Text、Clob和Blob等字符类型。String类型不限定字符集，因为它根本就没有这个概念，所以可以将任意编码的字符串存入其中。但是为了程序的规范性和可维护性，在同一套程序中应该遵循使用统一的编码，例如“统一保持UTF-8编码”就是一种很好的约定。</p>
<h2 id="fixedstring"><a class="header" href="#fixedstring">FixedString</a></h2>
<p>FixedString类型和传统意义上的Char类型有些类似，对于一些字符有明确长度的场合，可以使用固定长度的字符串。定长字符串通过FixedString(N)声明，其中N表示字符串长度。但与Char不同的是，FixedString使用null字节填充末尾字符，而Char通常使用空格填充。比如在下面的例子中，字符串‘abc’虽然只有3位，但长度却是5，因为末尾有2位空字符填充：</p>
<pre><code class="language-sql">:) SELECT toFixedString('abc',5) , LENGTH(toFixedString('abc',5)) AS LENGTH

┌─toFixedString('abc', 5)─┬─LENGTH──────┐
│ abc                     │ 5           │
└─────────────────────────┴─────────────┘
</code></pre>
<h2 id="uuid"><a class="header" href="#uuid">UUID</a></h2>
<p>UUID是一种数据库常见的主键类型，在ClickHouse中直接把它作为一种数据类型。UUID共有32位，它的格式为8-4-4-4-12。如果一个UUID类型的字段在写入数据时没有被赋值，则会依照格式使用0填充，例如：</p>
<pre><code class="language-sql">
CREATE TABLE UUID_TEST (
  c1 UUID,
  c2 String
) ENGINE = Memory;

--第一行UUID有值
INSERT INTO UUID_TEST SELECT generateUUIDv4(),'t1'
--第二行UUID没有值
INSERT INTO UUID_TEST(c2) VALUES ('t2')

:) SELECT * FROM UUID_TEST
┌─────────────────────c1─┬─c2─┐
│ f36c709e-1b73-4370-a703-f486bdd22749 │ t1 │
└───────────────────────┴────┘
┌─────────────────────c1─┬─c2─┐
│ 00000000-0000-0000-0000-000000000000 │ t2 │
└───────────────────────┴────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_datetime.html#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">时间类型</a>
<ul>
<li><a href="clickhouse/base_type_datetime.html#datetime">DateTime</a></li>
<li><a href="clickhouse/base_type_datetime.html#datetime64">DateTime64</a></li>
<li><a href="clickhouse/base_type_datetime.html#date">Date</a></li>
<li><a href="clickhouse/base_type_datetime.html#date32">Date32</a></li>
</ul>
</li>
</ul>
<h1 id="时间类型"><a class="header" href="#时间类型">时间类型</a></h1>
<p>时间类型分为<code>DateTime</code>、<code>DateTime64</code>、<code>Date</code>、<code>Date32</code>四类。ClickHouse目前没有时间戳类型。</p>
<p>时间类型最高的精度是秒，也就是说，如果需要处理毫秒、微秒等大于秒分辨率的时间，则只能借助<code>UInt</code>类型实现.</p>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>DateTime类型包含时、分、秒信息，精确到秒，支持使用字符串形式写入：</p>
<pre><code class="language-sql">CREATE TABLE Datetime_TEST (
    c1 Datetime
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Datetime_TEST VALUES('2019-06-22 00:00:00')
 
 SELECT c1, toTypeName(c1) FROM Datetime_TEST

┌──────────c1─┬─toTypeName(c1)───────────┐
│ 2019-06-22 00:00:00 │  DateTime        │
└─────────────────────┴──────────────────┘
</code></pre>
<h2 id="datetime64"><a class="header" href="#datetime64">DateTime64</a></h2>
<p>DateTime64可以记录亚秒，它在DateTime之上增加了精度的设置，例如：</p>
<pre><code class="language-sql">CREATE TABLE Datetime64_TEST (
    c1 Datetime64(2)    
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Datetime64_TEST VALUES('2019-06-22 00:00:00')
 
SELECT c1, toTypeName(c1) FROM Datetime64_TEST

┌─────────────c1─┬─toTypeName(c1)─────────┐
│ 2019-06-22 00:00:00.00 │ DateTime       │
└────────────────────────┴────────────────┘
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>Date类型不包含具体的时间信息，只精确到天，它同样也支持字符串形式写入：</p>
<pre><code class="language-sql">CREATE TABLE Date_TEST (
  c1 Date
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Date_TEST VALUES('2019-06-22')

SELECT c1, toTypeName(c1) FROM Date_TEST

┌─────────c1─┬─toTypeName(c1)────────┐
│ 2019-06-22       │ Date            │
└──────────────────┴─────────────────┘

</code></pre>
<h2 id="date32"><a class="header" href="#date32">Date32</a></h2>
<blockquote>
<p>注意: <a href="https://clickhouse.com/docs/zh/whats-new/changelog/#clickhouse-release-v22-1-2022-01-18">v22.1</a>版本中新增支持。</p>
</blockquote>
<p>一个日期。 支持与 <a href="clickhouse/base_type_datetime.html#datetime64">Datetime64</a> 相同的日期范围。 存储自 <code>1925-01-01</code> 以来的天数，占用4个字节。 允许将日期存储到<code>2283-11-11</code>。</p>
<pre><code class="language-sql">CREATE TABLE Date32_TEST ( c1 Date32 ) ENGINE = Memory

--以字符串形式写入
INSERT INTO Date32_TEST VALUES('2282-06-22')

SELECT c1, toTypeName(c1) FROM Date32_TEST

┌─────────c1─┬─toTypeName(c1)────────┐
│ 2282-06-22       │ Date32          │
└──────────────────┴─────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合数据类型"><a class="header" href="#复合数据类型">复合数据类型</a></h1>
<p>除了基础数据类型之外，ClickHouse还提供了数组、元组、枚举和嵌套四类复合类型。这些类型通常是其他数据库原生不具备的特性。拥有了复合类型之后，ClickHouse的数据模型表达能力更强了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p><strong>数组有两种定义形式</strong></p>
<ul>
<li>
<p>常规方式array(T)</p>
<pre><code class="language-sql">SELECT array(1, 2) as a , toTypeName(a)
┌─a─────┬─toTypeName(array(1, 2))─┐
│ [1,2] │ Array(UInt8)            │
└───────┴─────────────────────────┘
</code></pre>
</li>
<li>
<p>简写方式[T]:</p>
<pre><code class="language-sql">SELECT [1, 2]
</code></pre>
</li>
</ul>
<p>因为ClickHouse的数组拥有类型推断的能力, 所以在查询时并不需要主动声明数组的元素类型。</p>
<p>推断依据：以最小存储代价为原则，即使用最小可表达的数据类型。</p>
<p>例如在例子中，<code>array(1,2)</code>会通过自动推断将<code>UInt8</code>作为数组类型。但是数组元素中如果存在<code>Null</code>值，则元素类型将变为<code>Nullable</code>，例如：</p>
<pre><code class="language-sql">SELECT [1, 2, null] as a , toTypeName(a)
┌─a──────┬─toTypeName([1, 2, NULL])────┐
│ [1,2,NULL] │ Array(Nullable(UInt8))  │
└────────┴─────────────────────────────┘
</code></pre>
<p>在同一个数组内可以包含多种数据类型，例如数组<code>[1,2.0]</code>是可行的。但各类型之间必须兼容，例如数组<code>[1,'2']</code>则会报错。</p>
<p>在定义表字段时，数组需要指定明确的元素类型，例如：</p>
<pre><code class="language-sql">CREATE TABLE Array_TEST (
  c1 Array(String)
) engine = Memory
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组类型由<code>1～n</code>个元素组成，每个元素之间允许设置不同的数据类型，且彼此之间不要求兼容。</p>
<p>元组同样支持类型推断，其推断依据仍然以最小存储代价为原则。</p>
<p>与数组类似，元组也可以使用两种方式定义:</p>
<ul>
<li>
<p><strong>常规方式</strong><code>tuple(T)</code>：</p>
<pre><code class="language-sql">
SELECT tuple(1,'a',now()) AS x, toTypeName(x)
┌─x─────────────────────────────┬─toTypeName(tuple(1, 'a', now()))──┐
│ (1,'a','2019-08-28 21:36:32') │ Tuple(UInt8, String, DateTime)    │
└───────────────────────────────┴───────────────────────────────────┘
</code></pre>
</li>
<li>
<p><strong>简写方式（T）</strong>:</p>
</li>
</ul>
<pre><code class="language-sql">SELECT (1,2.0,null) AS x, toTypeName(x)
┌─x────────────┬─toTypeName(tuple(1, 2., NULL))───────────┐
│ (1,2,NULL)   │ Tuple(UInt8, Float64, Nullable(Nothing)) │
└──────────────┴──────────────────────────────────────────┘
</code></pre>
<p>在定义表字段时，元组需要指定明确的元素类型：</p>
<pre><code class="language-sql">CREATE TABLE Tuple_TEST (
  c1 Tuple(String,Int8)
) ENGINE = Memory;
</code></pre>
<p>元素类型和泛型的作用类似，可以进一步保障数据质量。在数据写入的过程中会进行类型检查。</p>
<p>例如，写入<code>INSERT INTO Tuple_TEST VALUES(('abc',123))</code>是可行的，而写入<code>INSERT INTO Tuple_TEST VALUES(('abc','efg'))</code>则会报错。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>ClickHouse支持枚举类型，这是一种在定义常量时经常会使用的数据类型。</p>
<p>ClickHouse提供了<code>Enum8</code>和<code>Enum16</code>两种枚举类型，它们除了取值范围不同之外，别无二致。</p>
<p>枚举固定使用 (String:Int) Key/Value键值对的形式定义数据，</p>
<p>所以<code>Enum8</code>和<code>Enum16</code>分别会对应<code>(String:Int8)</code>和<code>(String:Int16)</code>，例如：</p>
<pre><code class="language-sql">CREATE TABLE Enum_TEST (
    c1 Enum8('ready' = 1, 'start' = 2, 'success' = 3, 'error' = 4)
) ENGINE = Memory;
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>Key和Value是不允许重复的，要保证唯一性。</p>
</li>
<li>
<p>Key和Value的值都不能为Null，但Key允许是空字符串</p>
</li>
</ul>
<p>在写入枚举数据的时候，只会用到Key字符串部分，例如：</p>
<pre><code class="language-sql">INSERT INTO Enum_TEST VALUES('ready');
INSERT INTO Enum_TEST VALUES('start');
</code></pre>
<p>数据在写入的过程中，会对照枚举集合项的内容逐一检查。如果Key字符串不在集合范围内则会抛出异常，比如执行下面的语句就会出错：</p>
<pre><code class="language-sql">INSERT INTO Enum_TEST VALUES('stop');
</code></pre>
<p>枚举完全可以使用String代替枚举，为什么还需要专门的枚举类型呢？</p>
<p>这是出于性能的考虑。因为虽然枚举定义中的Key属于String类型，但是在后续对枚举的所有操作中（包括排序、分组、去重、过滤等），会使用Int类型的Value值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌套"><a class="header" href="#嵌套">嵌套</a></h1>
<p>嵌套类型，顾名思义是一种嵌套表结构。</p>
<p>一张数据表，可以定义任意多个嵌套类型字段，但每个字段的嵌套层级只支持一级，即嵌套表内不能继续使用嵌套类型。</p>
<p>对于简单场景的层级关系或关联关系，使用嵌套类型也是一种不错的选择。</p>
<p>例如，下面的nested_test是一张模拟的员工表，它的所属部门字段就使用了嵌套类型：</p>
<pre><code class="language-sql">CREATE TABLE nested_test (
  name String,
  age  UInt8 ,
  dept Nested(
  id UInt8,
  name String
)
) ENGINE = Memory;
</code></pre>
<p>ClickHouse的嵌套类型和传统的嵌套类型不相同，导致在初次接触它的时候会让人十分困惑。以上面这张表为例，如果按照它的字面意思来理解，会很容易理解成nested_test与dept是一对一的包含关系，其实这是错误的。不信可以执行下面的语句，看看会是什么结果：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('nauu',18, 10000, '研发部');
Exception on client:
Code: 53. DB::Exception: Type mismatch in IN or VALUES section. Expected: Array(UInt8). Got: UInt64
</code></pre>
<p>注意上面的异常信息，它提示期望写入的是一个Array数组类型。</p>
<p><strong>嵌套类型本质是一种多维数组的结构。嵌套表中的每个字段都是一个数组，同一行数据中数据必须对其，但行与行之间数组的长度无须对齐。</strong></p>
<p>所以需要把刚才的INSERT语句调整成下面的形式：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001,10002], ['研发部','技术支持中心','测试部']);
--行与行之间,数组长度无须对齐
INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001], ['研发部','技术支持中心']);
</code></pre>
<p>需要注意的是，在同一行数据内每个数组字段的长度必须相等。例如，在下面的示例中，由于行内数组字段的长度没有对齐，所以会抛出异常：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001], ['研发部','技术支持中心', '测试部']); 
DB::Exception: Elements 'dept.id' and 'dept.name' of Nested data structure 'dept' (Array columns) have different array sizes..
</code></pre>
<p>在访问嵌套类型的数据时需要使用点符号，例如：</p>
<pre><code class="language-sql">SELECT name, dept.id, dept.name FROM nested_test

┌─name──┬─dept.id────┬────dept.name───────────────────┐
│ bruce │ [16,17,18] │ ['研发部','技术支持中心','测试部'] │
└───────┴────────────┴────────────────────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特殊类型"><a class="header" href="#特殊类型">特殊类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable"><a class="header" href="#nullable">Nullable</a></h1>
<p>原文：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/">https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/</a></p>
<p>准确来说，Nullable并不能算是一种独立的数据类型，它更像是一种辅助的修饰符，需要与基础数据类型一起搭配使用。</p>
<p>Nullable类型与Java8的Optional对象有些相似，它表示某个基础数据类型可以是Null值。</p>
<pre><code class="language-sql">CREATE TABLE Null_TEST (
  c1 String,
  c2 Nullable(UInt8)
) ENGINE = TinyLog;

- 通过Nullable修饰后c2字段可以被写入Null值：

INSERT INTO Null_TEST VALUES ('nauu',null)
INSERT INTO Null_TEST VALUES ('bruce',20)

SELECT c1 , c2 ,toTypeName(c2) FROM Null_TEST

┌───c1───┬────c2───┬──toTypeName(c2)─┐
│ nauu   │ NULL    │ Nullable(UInt8) │
│ bruce  │ 20      │ Nullable(UInt8) │
└────────┴─────────┴─────────────────┘
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>它只能和基础类型搭配使用，不能用于数组和元组这些复合类型，也不能作为索引字段</p>
</li>
<li>
<p>慎用Nullable类型，包括Nullable的数据表，不然会使查询和写入性能变慢。【因为在正常情况下，每个列字段的数据会被存储在对应的[Column].bin文件中。如果一个列字段被Nullable类型修饰后，会额外生成一个[Column].null.bin文件专门保存它的Null值。这意味着在读取和写入数据时，需要一倍的额外文件操作。】</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain"><a class="header" href="#domain">Domain</a></h1>
<p>域名类型分为IPv4和IPv6两类，本质上它们是对整型和字符串的进一步封装。IPv4类型是基于UInt32封装的。</p>
<pre><code class="language-sql">CREATE TABLE IP4_TEST (
  url String,
  ip IPv4
) ENGINE = Memory;

INSERT INTO IP4_TEST VALUES ('www.nauu.com','192.0.0.0')

SELECT url , ip ,toTypeName(ip) FROM IP4_TEST

┌─url──────────┬─────ip────┬─toTypeName(ip)───────┐
│ www.nauu.com │ 192.0.0.0 │     IPv4             │
└──────────────┴───────────┴──────────────────────┘
</code></pre>
<p>直接使用字符串不就行了吗？</p>
<ul>
<li>
<p>（1）出于便捷性的考量，例如IPv4类型支持格式检查，格式错误的IP数据是无法被写入的，例如：</p>
<pre><code class="language-sql">INSERT INTO IP4_TEST VALUES ('www.nauu.com','192.0.0')
Code: 441. DB::Exception: Invalid IPv4 value.
</code></pre>
</li>
<li>
<p>（2）出于性能的考量，同样以IPv4为例，IPv4使用UInt32存储，相比String更加紧凑，占用的空间更小，查询性能更快。IPv6类型是基于FixedString(16)封装的，它的使用方法与IPv4别无二致.</p>
</li>
</ul>
<p>在使用Domain类型的时候还有一点需要注意，虽然它从表象上看起来与String一样，但Domain类型并不是字符串，所以它不支持隐式的自动类型转换。</p>
<p>如果需要返回IP的字符串形式，则需要显式调用<a href="https://clickhouse.com/docs/en/sql-reference/functions/ip-address-functions/#ipv4numtostringnum">IPv4NumToString</a>或<a href="https://clickhouse.com/docs/en/sql-reference/functions/ip-address-functions/#ipv6numtostringx">IPv6NumToString</a>函数进行转换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义数据表"><a class="header" href="#定义数据表">定义数据表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库"><a class="header" href="#数据库">数据库</a></h1>
<p>数据库起到了命名空间的作用，可以有效规避命名冲突的问题，也为后续的数据隔离提供了支撑。</p>
<p>任何一张数据表，都必须归属在某个数据库之下。</p>
<p>创建数据库的完整语法如下所示：</p>
<pre><code class="language-sql">CREATE DATABASE IF NOT EXISTS db_name [ENGINE = engine]
</code></pre>
<p>其中，<code>IF NOT EXISTS</code>表示如果已经存在一个同名的数据库，则会忽略后续的创建过程；<code>[ENGINE=engine]</code>表示数据库所使用的引擎类型.</p>
<p>数据库目前一共支持5种引擎，如下所示。</p>
<ul>
<li><strong>Ordinary</strong>：默认引擎，在绝大多数情况下我们都会使用默认引擎，使用时无须刻意声明。在此数据库下可以使用任意类型的表引擎。</li>
<li><strong>Dictionary</strong>：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表，关于数据字典的详细介绍会在第5章展开。</li>
<li><strong>Memory</strong>：内存引擎，用于存放临时数据。此类数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除。</li>
<li><strong>Lazy</strong>：日志引擎，此类数据库下只能使用Log系列的表引擎，关于Log表引擎的详细介绍会在第8章展开。</li>
<li><strong>MySQL</strong>：MySQL引擎，此类数据库下会自动拉取远端MySQL中的数据，并为它们创建MySQL表引擎的数据表。</li>
</ul>
<p>在绝大多数情况下都只需使用默认的数据库引擎。例如执行下面的语句，即能够创建属于我们的第一个数据库：</p>
<pre><code class="language-sql">CREATE DATABASE DB_TEST
</code></pre>
<p>默认数据库的实质是物理磁盘上的一个文件目录，所以在语句执行之后，ClickHouse便会在安装路径下创建DB_TEST数据库的文件目录：</p>
<pre><code class="language-shell"># pwd
/chbase/data
# ls
DB_TEST  default  system
</code></pre>
<p>与此同时，在metadata路径下也会一同创建用于恢复数据库的DB_TEST.sql文件：</p>
<pre><code class="language-shell"># pwd
/chbase/data/metadata
# ls
DB_TEST  DB_TEST.sql  default  system
</code></pre>
<p>使用SHOW DATABASES查询，即能够返回ClickHouse当前的数据库列表：</p>
<pre><code class="language-shell">SHOW DATABASES
┌─name──────┐
│  DB_TEST  │
│  default  │
│  system   │
└───────────┘
</code></pre>
<p>使用USE查询可以实现在多个数据库之间进行切换，而通过SHOW TABLES查询可以查看当前数据库的数据表列表。删除一个数据库，则需要用到下面的DROP查询。</p>
<pre><code class="language-sql">DROP DATABASE [IF EXISTS] db_name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据表"><a class="header" href="#数据表">数据表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字段默认值表达式"><a class="header" href="#字段默认值表达式">字段默认值表达式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="临时表"><a class="header" href="#临时表">临时表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分区表"><a class="header" href="#分区表">分区表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="视图"><a class="header" href="#视图">视图</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用语句"><a class="header" href="#常用语句">常用语句</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询数据大小"><a class="header" href="#查询数据大小">查询数据大小</a></h1>
<h2 id="mysql-1"><a class="header" href="#mysql-1">MYSQL</a></h2>
<pre><code class="language-sql">select
 table_schema as '数据库',
 table_name as '表名',
 table_rows as '记录数',
 truncate(data_length / 1024 / 1024, 2) as '数据容量(MB)',
 truncate(index_length / 1024 / 1024, 2) as '索引容量(MB)'
from
 information_schema.tables
order by
 data_length desc,
 index_length desc;
</code></pre>
<h2 id="clickhouse-1"><a class="header" href="#clickhouse-1">ClickHouse</a></h2>
<h3 id="查看数据库容量行数压缩率"><a class="header" href="#查看数据库容量行数压缩率">查看数据库容量、行数、压缩率</a></h3>
<pre><code class="language-sql">SELECT 
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌────总行数─┬─原始大小──┬─压缩大小─┬─压缩率─┐
│ 326819026 │ 77.15 GiB │ 5.75 GiB │      7 │
└───────────┴───────────┴──────────┴────────┘

1 rows in set. Elapsed: 0.047 sec. Processed 1.04 thousand rows, 520.93 KB (21.95 thousand
rows/s., 11.02 MB/s.) 
</code></pre>
<h3 id="查看数据表容量行数压缩率"><a class="header" href="#查看数据表容量行数压缩率">查看数据表容量、行数、压缩率</a></h3>
<pre><code class="language-sql">SELECT 
    table AS `表名`,
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
WHERE table IN ('temp_1')
GROUP BY table
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─表名───┬──总行数─┬─原始大小───┬─压缩大小──┬─压缩率─┐
│ temp_1 │ 3127523 │ 838.21 MiB │ 60.04 MiB │      7 │
└────────┴─────────┴────────────┴───────────┴────────┘

1 rows in set. Elapsed: 0.008 sec.
</code></pre>
<h3 id="查看数据表分区信息"><a class="header" href="#查看数据表分区信息">查看数据表分区信息</a></h3>
<pre><code class="language-sql">--查看测试表在19年12月的分区信息
SELECT 
    partition AS `分区`,
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
WHERE (database IN ('default')) AND (table IN ('temp_1')) AND (partition LIKE '2019-12-%')
GROUP BY partition
ORDER BY partition ASC
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─分区───────┬─总行数─┬─原始大小──┬─压缩大小───┬─压缩率─┐
│ 2019-12-01 │     24 │ 6.17 KiB  │ 2.51 KiB   │     41 │
│ 2019-12-02 │   9215 │ 2.45 MiB  │ 209.74 KiB │      8 │
│ 2019-12-03 │  17265 │ 4.46 MiB  │ 453.78 KiB │     10 │
│ 2019-12-04 │  27741 │ 7.34 MiB  │ 677.25 KiB │      9 │
│ 2019-12-05 │  31500 │ 8.98 MiB  │ 469.30 KiB │      5 │
│ 2019-12-06 │    157 │ 37.50 KiB │ 4.95 KiB   │     13 │
│ 2019-12-07 │    110 │ 32.75 KiB │ 3.86 KiB   │     12 │
└────────────┴────────┴───────────┴────────────┴────────┘

7 rows in set. Elapsed: 0.005 sec. 
</code></pre>
<h3 id="查看数据表字段的信息"><a class="header" href="#查看数据表字段的信息">查看数据表字段的信息</a></h3>
<pre><code class="language-sql">SELECT 
    column AS `字段名`,
    any(type) AS `类型`,
    formatReadableSize(sum(column_data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(column_data_compressed_bytes)) AS `压缩大小`,
    sum(rows) AS `行数`
FROM system.parts_columns
WHERE (database = 'default') AND (table = 'temp_1')
GROUP BY column
ORDER BY column ASC
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─字段名───────────┬─类型─────┬─原始大小───┬─压缩大小───┬────行数─┐
│ a                │ String   │ 23.83 MiB  │ 134.13 KiB │ 3127523 │
│ b                │ String   │ 19.02 MiB  │ 127.72 KiB │ 3127523 │
│ c                │ String   │ 5.97 MiB   │ 49.09 KiB  │ 3127523 │
│ d             │ String   │ 3.95 MiB   │ 532.86 KiB │ 3127523 │
│ e                │ String   │ 5.17 MiB   │ 49.47 KiB  │ 3127523 │
│ totalDate        │ DateTime │ 11.93 MiB  │ 1.26 MiB   │ 3127523 │
└──────────────────┴──────────┴────────────┴────────────┴─────────┘
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
