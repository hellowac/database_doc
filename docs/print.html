<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据库相关的记录文档</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="introduction.html">简介</a></li><li class="spacer"></li><li class="chapter-item "><div>SQL</div></li><li class="chapter-item "><a href="mysql/index.html">MySQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mysql/introduction.html">简介</a></li></ol></li><li class="chapter-item "><a href="postgre/index.html">PostgreSQL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="postgre/introduction.html">简介</a></li></ol></li><li class="chapter-item "><a href="clickhouse/index.html">ClickHouse</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/clickhouse-sqlalchemy.html">Clickhouse-SQLAlchemy</a></li><li class="chapter-item "><a href="clickhouse/clickhouse-driver.html">Clickhouse-driver</a></li><li class="chapter-item "><a href="clickhouse/connecti.html">连接数据库</a></li><li class="chapter-item "><a href="clickhouse/inner_tools.html">内置工具</a></li><li class="chapter-item "><a href="clickhouse/define_data.html">数据定义</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/define_data_base_type.html">基础数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/base_type_int.html">数值类型</a></li><li class="chapter-item "><a href="clickhouse/base_type_string.html">字符串类型</a></li><li class="chapter-item "><a href="clickhouse/base_type_datetime.html">时间类型</a></li></ol></li><li class="chapter-item "><a href="clickhouse/define_data_complex_type.html">复合数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/complex_type_array.html">数组</a></li><li class="chapter-item "><a href="clickhouse/complex_type_tuple.html">元组</a></li><li class="chapter-item "><a href="clickhouse/complex_type_enum.html">枚举</a></li><li class="chapter-item "><a href="clickhouse/complex_type_nested.html">嵌套</a></li></ol></li><li class="chapter-item "><a href="clickhouse/special_type.html">特殊类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/special_type_nullable.html">Nullable</a></li><li class="chapter-item "><a href="clickhouse/special_type_domain.html">Domain</a></li></ol></li></ol></li><li class="chapter-item "><a href="clickhouse/define_data_table_index.html">定义数据表</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/define_database.html">数据库</a></li><li class="chapter-item "><a href="clickhouse/define_data_table.html">数据表</a></li><li class="chapter-item "><a href="clickhouse/define_field_default.html">字段默认值表达式</a></li><li class="chapter-item "><a href="clickhouse/define_temp_data_table.html">临时表</a></li><li class="chapter-item "><a href="clickhouse/define_partition_data_table.html">分区表</a></li><li class="chapter-item "><a href="clickhouse/define_view_data_table.html">视图</a></li></ol></li><li class="chapter-item "><a href="clickhouse/op_table_index.html">表的操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/op_table_add_column.html">追加字段</a></li><li class="chapter-item "><a href="clickhouse/op_table_alter_data_type.html">修改数据类型</a></li><li class="chapter-item "><a href="clickhouse/op_table_alter_comment.html">修改备注</a></li><li class="chapter-item "><a href="clickhouse/op_table_delete_column.html">删除已有字段</a></li><li class="chapter-item "><a href="clickhouse/op_table_move_data.html">移动数据表</a></li><li class="chapter-item "><a href="clickhouse/op_table_truncate_data.html">清空数据表</a></li></ol></li><li class="chapter-item "><a href="clickhouse/op_partition_index.html">数据分区操作</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="clickhouse/op_partition_query.html">查询分区信息</a></li><li class="chapter-item "><a href="clickhouse/op_partition_delete.html">删除指定分区</a></li><li class="chapter-item "><a href="clickhouse/op_partition_copy.html">复制分区数据</a></li><li class="chapter-item "><a href="clickhouse/op_partition_reset.html">重置分区数据</a></li><li class="chapter-item "><a href="clickhouse/op_partition_load.html">卸载与装载分区</a></li><li class="chapter-item "><a href="clickhouse/op_partition_backup.html">备份与还原分区</a></li></ol></li><li class="chapter-item "><a href="clickhouse/op_distribute_ddl.html">分布式DDL执行</a></li><li class="chapter-item "><a href="clickhouse/insert_data.html">数据的写入</a></li><li class="chapter-item "><a href="clickhouse/modify_and_delete_data.html">数据的删除与修改</a></li></ol></li><li class="chapter-item "><a href="scripts/script_select_size.html">常用语句</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scripts/select_data_size.html">查询数据大小</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">数据库相关的记录文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>本文档主要记录与数据库相关的技术、技巧、问题等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mysql"><a class="header" href="#mysql">MySQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="postgresql"><a class="header" href="#postgresql">PostgreSQL</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse"><a class="header" href="#clickhouse">ClickHouse</a></h1>
<p>官网：<a href="https://clickhouse.com/docs/en/">https://clickhouse.com/docs/en/</a></p>
<p>ClickHouse拥有完备的管理功能，所以它称得上是一个DBMS（Database Management System，数据库管理系统），而不仅是一个数据库。一些基本功能，如下所示：</p>
<ul>
<li><strong>DDL</strong>（数据定义语言）：可以动态地创建、修改或删除数据库、表和视图，而无须重启服务。</li>
<li><strong>DML</strong>（数据操作语言）：可以动态查询、插入、修改或删除数据。</li>
<li><strong>权限控制</strong>：可以按照用户粒度设置数据库或者表的操作权限，保障数据的安全性。</li>
<li><strong>数据备份与恢复</strong>：提供了数据备份导出与导入恢复机制，满足生产环境的要求。</li>
<li><strong>分布式管理</strong>：提供集群模式，能够自动管理多个数据库节点。</li>
</ul>
<p>ClickHouse就是一款使用<code>列式存储</code>的数据库，数据按列进行组织，属于同一列的数据会被保存在一起，列与列之间也会由不同的文件分别保存. 【主要针对<a href="https://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/">MergeTree</a>引擎】</p>
<p>ClickHouse目前利用<code>SSE4.2指令集</code>实现向量化执行。</p>
<p>ClickHouse是大小写敏感的，这意味着<code>SELECT a</code>和<code>SELECT A</code>所代表的语义是不同的。</p>
<p>ClickHouse在数据存取方面，既支持分区（纵向扩展，利用多线程原理），也支持分片（横向扩展，利用分布式原理），ClickHouse将多线程和分布式的技术应用到了极致。</p>
<p>ClickHouse则采用<code>Multi-Master多主架构</code>，集群中的每个节点角色对等，客户端访问任意一个节点都能得到相同的效果。</p>
<p>ClickHouse支持分片，而分片则依赖集群。每个集群由1到多个分片组成，而每个分片则对应了ClickHouse的1个服务节点。分片的数量上限取决于节点数量（1个分片只能对应1个服务节点）。【数据分片是将数据进行横向切分，这是一种在面对海量数据的场景下，解决存储和查询瓶颈的有效手段，是一种分治思想的体现。】</p>
<p>ClickHouse提供了本地表（Local Table）与分布式表（Distributed Table）的概念。一张本地表等同于一份数据的分片。而分布式表本身不存储任何数据，它是本地表的访问代理，其作用类似分库中间件。借助分布式表，能够代理访问多个数据分片，从而实现分布式查询。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#clickhouse-sqlalchemy">Clickhouse-SQLAlchemy</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%AE%89%E8%A3%85">安装</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E6%8E%A5%E5%8F%A3%E6%94%AF%E6%8C%81">接口支持</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%BF%9E%E6%8E%A5%E5%8F%82%E6%95%B0">连接参数</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E9%A9%B1%E5%8A%A8%E9%80%89%E9%A1%B9">驱动选项</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%8A%9F%E8%83%BD">功能</a>
<ul>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#sqlalchemy-%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%94%AF%E6%8C%81">SQLAlchemy 声明式支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%9F%BA%E6%9C%AC%E7%9A%84ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E6%94%AF%E6%8C%81">基本的DDL(数据定义)支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%9F%BA%E6%9C%AC-insert-%E5%AD%90%E5%8F%A5%E6%94%AF%E6%8C%81">基本 INSERT 子句支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E5%B8%B8%E8%A7%81%E7%9A%84-sqlalchemy-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95">常见的 SQLAlchemy 链式查询方法</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E9%AB%98%E7%BA%A7-insert-%E5%AD%90%E5%8F%A5%E6%94%AF%E6%8C%81">高级 INSERT 子句支持</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E7%94%A8%E4%BA%8E%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E7%9A%84%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE">用于查询处理的外部数据</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E6%94%AF%E6%8C%81%E7%9A%84-clickhouse-%E7%89%B9%E5%88%AB%E7%9A%84-sql">支持的 ClickHouse 特别的 SQL</a></li>
</ul>
</li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%A6%86%E7%9B%96%E9%BB%98%E8%AE%A4%E6%9F%A5%E8%AF%A2%E8%AE%BE%E7%BD%AE">覆盖默认查询设置</a></li>
<li><a href="clickhouse/clickhouse-sqlalchemy.html#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">运行测试</a></li>
</ul>
</li>
</ul>
<h1 id="clickhouse-sqlalchemy"><a class="header" href="#clickhouse-sqlalchemy">Clickhouse-SQLAlchemy</a></h1>
<p>原文: <a href="https://github.com/xzkostyan/clickhouse-sqlalchemy/blob/master/README.rst">https://github.com/xzkostyan/clickhouse-sqlalchemy/blob/master/README.rst</a></p>
<p><strong>ClickHouse SQLAlchemy</strong> <a href="http://docs.sqlalchemy.org/en/latest/">SQLAlchemy</a>的连接Clickhouse数据库的方言版本。</p>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p>可以使用 pip 安装该软件包：</p>
<pre><code class="language-text">`pip install clickhouse-sqlalchemy`
</code></pre>
<h3 id="接口支持"><a class="header" href="#接口支持">接口支持</a></h3>
<ul>
<li>native 方式: 通过 <a href="https://github.com/mymarilyn/clickhouse-driver">clickhouse-driver</a> 【推荐】【TCP】</li>
<li>http 方式: 通过 <a href="https://2.python-requests.org/en/latest/">requests</a></li>
</ul>
<h2 id="连接参数"><a class="header" href="#连接参数">连接参数</a></h2>
<p>ClickHouse SQLAlchemy 使用下面的语法作为连接字符串:</p>
<pre><code class="language-text">'clickhouse+&lt;driver&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;database&gt;[?key=value..]'
</code></pre>
<p>注意:</p>
<ul>
<li><em>driver</em> 是驱动选项. 可选: <code>http</code>, <code>native</code>. 默认为 <code>http</code>.</li>
<li><em>database</em> 是要连接的数据库. 默认为 <code>default</code>数据库.</li>
</ul>
<h3 id="驱动选项"><a class="header" href="#驱动选项">驱动选项</a></h3>
<p>可以在查询字符串中指定几个选项。</p>
<p><strong>HTTP</strong></p>
<ul>
<li><code>port</code> 是ClickHouse绑定的端口. 默认为 <code>8123</code>.</li>
<li><code>timeout</code> 以秒为单位的超时. 无默认值.</li>
<li><code>protocol</code> 要使用的协议. 可选: <code>http</code>, <code>https</code>. 默认为 <code>http</code>.</li>
</ul>
<p>安装ClickHouse后，默认的测试连接字符串是：</p>
<pre><code class="language-text">'clickhouse://default:@localhost/test'
</code></pre>
<p>当您使用 nginx 作为 ClickHouse 的代理服务器时，服务器连接字符串可能如下所示：</p>
<pre><code class="language-text">'clickhouse://user:password@example.com:8124/test?protocol=https'
</code></pre>
<p>这里的<code>8124</code>是代理端口。</p>
<p>如果您需要控制底层 HTTP 连接，请将 <a href="https://requests.readthedocs.io/en/master/user/advanced/#session-objects">requests.Session</a> 实例传递给 <code>create_engine()</code>，如下所示：</p>
<pre><code class="language-python">from sqlalchemy import create_engine
from requests import Session

uri = 'clickhouse://default:@localhost/test'

engine = create_engine(uri, connect_args={'http_session': Session()})
</code></pre>
<p><strong>Native</strong></p>
<p>请注意，<code>native</code>连接方式未加密。 包括用户/密码在内的所有数据都以纯文本形式传输。 通过不受信任的网络进行通信时，您应该通过 <code>SSH</code> 或 <code>VPN</code>（例如）使用此连接。</p>
<p>安装ClickHouse后，默认的测试连接字符串是：</p>
<pre><code class="language-text">'clickhouse+native://default:@localhost/test'
</code></pre>
<p>所有连接字符串参数都代理到 clickhouse-driver。 参考其<a href="https://clickhouse-driver.readthedocs.io/en/latest/api.html#clickhouse_driver.connection.Connection">parameters</a></p>
<h2 id="功能"><a class="header" href="#功能">功能</a></h2>
<h3 id="sqlalchemy-声明式支持"><a class="header" href="#sqlalchemy-声明式支持">SQLAlchemy 声明式支持</a></h3>
<p>ORM声明式和构造表的函数式两种方式都支持：</p>
<pre><code class="language-python">from sqlalchemy import create_engine, Column, MetaData, literal

from clickhouse_sqlalchemy import Table, make_session, get_declarative_base, types, engines

uri = 'clickhouse://default:@localhost/test'

engine = create_engine(uri)
session = make_session(engine)
metadata = MetaData(bind=engine)

Base = get_declarative_base(metadata=metadata)

class Rate(Base):
    day = Column(types.Date, primary_key=True)
    value = Column(types.Int32)
    other_value = Column(
        types.DateTime,
        clickhouse_codec=('DoubleDelta', 'ZSTD'),
    )

    __table_args__ = (
        engines.Memory(),
    )

another_table = Table('another_rate', metadata,
    Column('day', types.Date, primary_key=True),
    Column('value', types.Int32, server_default=literal(1)),
    engines.Memory()
)
</code></pre>
<p>以声明方式创建的表名具有小写字母，单词由下划线命名约定分隔。 但是您可以通过 SQLAlchemy 的 <code>__tablename__</code> 属性轻松设置您自己的表名。</p>
<h3 id="基本的ddl数据定义支持"><a class="header" href="#基本的ddl数据定义支持">基本的DDL(数据定义)支持</a></h3>
<p>您可以发出简单的 DDL。 例如 CREATE/DROP 表：</p>
<pre><code class="language-python">table = Rate.__table__
table.create()
another_table.create()


another_table.drop()
table.drop()
</code></pre>
<h3 id="基本-insert-子句支持"><a class="header" href="#基本-insert-子句支持">基本 INSERT 子句支持</a></h3>
<p>简单的批量插入：</p>
<pre><code class="language-python">from datetime import date, timedelta
from sqlalchemy import func

today = date.today()
rates = [{'day': today - timedelta(i), 'value': 200 - i} for i in range(100)]

# Emits single INSERT statement.
session.execute(table.insert(), rates)
</code></pre>
<h3 id="常见的-sqlalchemy-链式查询方法"><a class="header" href="#常见的-sqlalchemy-链式查询方法">常见的 SQLAlchemy 链式查询方法</a></h3>
<p><code>order_by</code>, <code>filter</code>, <code>limit</code>, <code>offset</code>等都是支持的：</p>
<pre><code class="language-python">session.query(func.count(Rate.day)) \
    .filter(Rate.day &gt; today - timedelta(20)) \
    .scalar()

session.query(Rate.value) \
    .order_by(Rate.day.desc()) \
    .first()

session.query(Rate.value) \
    .order_by(Rate.day) \
    .limit(10) \
    .all()

session.query(func.sum(Rate.value)) \
    .scalar()
</code></pre>
<h3 id="高级-insert-子句支持"><a class="header" href="#高级-insert-子句支持">高级 INSERT 子句支持</a></h3>
<p>INSERT FROM SELECT 语句:</p>
<pre><code class="language-python">from sqlalchemy import cast

# Labels must be present.
select_query = session.query(
    Rate.day.label('day'),
    cast(Rate.value * 1.5, types.Int32).label('value')
).subquery()

# Emits single INSERT FROM SELECT statement
session.execute(
    another_table.insert()
    .from_select(['day', 'value'], select_query)
)
</code></pre>
<p>许多但不是所有的 SQLAlchemy 特性都支持开箱即用。</p>
<p>UNION ALL 示例：</p>
<pre><code class="language-python">from sqlalchemy import union_all

select_rate = session.query(
    Rate.day.label('date'),
    Rate.value.label('x')
)
select_another_rate = session.query(
    another_table.c.day.label('date'),
    another_table.c.value.label('x')
)

union_all(select_rate, select_another_rate).execute().fetchone()
</code></pre>
<h3 id="用于查询处理的外部数据"><a class="header" href="#用于查询处理的外部数据">用于查询处理的外部数据</a></h3>
<p>目前可以与native方式的接口一起使用:</p>
<pre><code class="language-python">ext = Table(
    'ext', metadata, Column('x', types.Int32),
    clickhouse_data=[(101, ), (103, ), (105, )], extend_existing=True
)

rv = session.query(Rate) \
    .filter(Rate.value.in_(session.query(ext.c.x))) \
    .execution_options(external_tables=[ext]) \
    .all()

print(rv)
</code></pre>
<h3 id="支持的-clickhouse-特别的-sql"><a class="header" href="#支持的-clickhouse-特别的-sql">支持的 ClickHouse 特别的 SQL</a></h3>
<ul>
<li><strong>SELECT query</strong>:
<ul>
<li><strong>WITH TOTALS</strong></li>
<li><strong>SAMPLE</strong></li>
<li><strong>lambda functions: x -&gt; expr</strong></li>
<li><strong>JOIN</strong></li>
</ul>
</li>
</ul>
<p>示例请参考 <a href="https://github.com/xzkostyan/clickhouse-sqlalchemy/tree/master/tests">tests</a></p>
<h2 id="覆盖默认查询设置"><a class="header" href="#覆盖默认查询设置">覆盖默认查询设置</a></h2>
<p>设置较低的查询优先级并限制执行请求的最大线程数。</p>
<pre><code class="language-python">rv = session.query(func.sum(Rate.value)) \
    .execution_options(settings={'max_threads': 2, 'priority': 10}) \
    .scalar()

print(rv)
</code></pre>
<h2 id="运行测试"><a class="header" href="#运行测试">运行测试</a></h2>
<pre><code class="language-shell">mkvirtualenv testenv &amp;&amp; python setup.py test
</code></pre>
<p><code>pip</code> 将自动安装所有必需的模块进行测试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clickhouse-driver"><a class="header" href="#clickhouse-driver">Clickhouse-driver</a></h1>
<p>原文: <a href="https://github.com/mymarilyn/clickhouse-driver/blob/master/README.rst">https://github.com/mymarilyn/clickhouse-driver/blob/master/README.rst</a></p>
<p>具有Native (TCP) 接口支持的 ClickHouse Python 驱动程序。</p>
<p>异步包装器可用在: <a href="https://github.com/mymarilyn/aioch">https://github.com/mymarilyn/aioch</a></p>
<h2 id="功能-1"><a class="header" href="#功能-1">功能</a></h2>
<ul>
<li>基于外部数据的查询处理支持.</li>
<li>Query查询设置.</li>
<li>压缩支持.</li>
<li>TLS 支持.</li>
<li>类型支持:
<ul>
<li>Float32/64</li>
<li>[U]Int8/16/32/64/128/256</li>
<li>Date/Date32/DateTime('timezone')/DateTime64('timezone')</li>
<li>String/FixedString(N)</li>
<li>Enum8/16</li>
<li>Array(T)</li>
<li>Nullable(T)</li>
<li>Bool</li>
<li>UUID</li>
<li>Decimal</li>
<li>IPv4/IPv6</li>
<li>LowCardinality(T)</li>
<li>SimpleAggregateFunction(F, T)</li>
<li>Tuple(T1, T2, ...)</li>
<li>Nested</li>
<li>Map(key, value)</li>
</ul>
</li>
<li>Query查询进度信息。</li>
<li>基于Block块式的结果流传输.</li>
<li>读取查询配置文件信息.</li>
<li>接收服务器日志.</li>
<li>多主机支持.</li>
<li>Python DB API 2.0 规范支持.</li>
<li>可选的 NumPy 数组支持.</li>
</ul>
<h2 id="文档"><a class="header" href="#文档">文档</a></h2>
<p>文档可在 <a href="https://clickhouse-driver.readthedocs.io">https://clickhouse-driver.readthedocs.io</a> 获得。</p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>与服务器通信有两种方式：</p>
<ol>
<li>使用纯客户端；</li>
<li>使用数据库 API。</li>
</ol>
<p><strong>纯客户端</strong> 示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from clickhouse_driver import Client
&gt;&gt;&gt;
&gt;&gt;&gt; client = Client('localhost')
&gt;&gt;&gt;
&gt;&gt;&gt; client.execute('SHOW TABLES')
[('test',)]
&gt;&gt;&gt; client.execute('DROP TABLE IF EXISTS test')
[]
&gt;&gt;&gt; client.execute('CREATE TABLE test (x Int32) ENGINE = Memory')
[]
&gt;&gt;&gt; client.execute(
...     'INSERT INTO test (x) VALUES',
...     [{'x': 100}]
... )
1
&gt;&gt;&gt; client.execute('INSERT INTO test (x) VALUES', [[200]])
1
&gt;&gt;&gt; client.execute(
...     'INSERT INTO test (x) '
...     'SELECT * FROM system.numbers LIMIT %(limit)s',
...     {'limit': 3}
... )
[]
&gt;&gt;&gt; client.execute('SELECT sum(x) FROM test')
[(303,)]
</code></pre>
<p><strong>数据库API</strong> 示例:</p>
<pre><code class="language-python">&gt;&gt;&gt; from clickhouse_driver import connect
&gt;&gt;&gt;
&gt;&gt;&gt; conn = connect('clickhouse://localhost')
&gt;&gt;&gt; cursor = conn.cursor()
&gt;&gt;&gt;
&gt;&gt;&gt; cursor.execute('SHOW TABLES')
&gt;&gt;&gt; cursor.fetchall()
[('test',)]
&gt;&gt;&gt; cursor.execute('DROP TABLE IF EXISTS test')
&gt;&gt;&gt; cursor.fetchall()
[]
&gt;&gt;&gt; cursor.execute('CREATE TABLE test (x Int32) ENGINE = Memory')
&gt;&gt;&gt; cursor.fetchall()
[]
&gt;&gt;&gt; cursor.executemany(
...     'INSERT INTO test (x) VALUES',
...     [{'x': 100}]
... )
&gt;&gt;&gt; cursor.rowcount
1
&gt;&gt;&gt; cursor.executemany('INSERT INTO test (x) VALUES', [[200]])
&gt;&gt;&gt; cursor.rowcount
1
&gt;&gt;&gt; cursor.execute(
...     'INSERT INTO test (x) '
...     'SELECT * FROM system.numbers LIMIT %(limit)s',
...     {'limit': 3}
... )
&gt;&gt;&gt; cursor.rowcount
0
&gt;&gt;&gt; cursor.execute('SELECT sum(x) FROM test')
&gt;&gt;&gt; cursor.fetchall()
[(303,)]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连接数据库"><a class="header" href="#连接数据库">连接数据库</a></h1>
<pre><code class="language-shell">&gt; clickhouse-client -h host -p port
</code></pre>
<p><strong>常见参数:</strong></p>
<ul>
<li>
<p>--host/-h：服务端的地址，默认值为localhost。</p>
<pre><code class="language-shell">&gt; clickhouse-client -h 10.37.129.10
</code></pre>
</li>
<li>
<p>--port：服务端的TCP端口，默认值为9000。</p>
</li>
<li>
<p>--user/-u：登录的用户名，默认值为default。</p>
</li>
<li>
<p>--password：登录的密码，默认值为空。</p>
</li>
<li>
<p>--database/-d：登录的数据库，默认值为default。</p>
</li>
<li>
<p>--query/-q：只能在非交互式查询时使用，用于指定SQL语句。</p>
</li>
<li>
<p>--multiquery/-n：在非交互式执行时，允许一次运行多条SQL语句，多条语句之间以分号间隔。</p>
</li>
<li>
<p>--time/-t：在非交互式执行时，会打印每条SQL的执行时间，例如</p>
<pre><code class="language-shell">&gt; clickhouse-client -h 10.37.129.10 -n -t --query=&quot;SELECT 1;SELECT 2;&quot;
1
0.002
2
0.001
</code></pre>
</li>
<li>
<p>完整的参数列表，可以通过--help查阅。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置工具"><a class="header" href="#内置工具">内置工具</a></h1>
<h2 id="clickhouse-local"><a class="header" href="#clickhouse-local">clickhouse-local</a></h2>
<p>clickhouse-local可以独立运行大部分SQL查询，不需要依赖任何ClickHouse的服务端程序，它可以理解成是ClickHouse服务的单机版微内核，是一个轻量级的应用程序。</p>
<p>clickhouse-local只能够使用File表引擎（关于表引擎的更多介绍在后续章节展开），它的数据与同机运行的ClickHouse服务也是完全隔离的，相互之间并不能访问。</p>
<p>clickhouse-local是非交互式运行的，每次执行都需要指定数据来源，例如通过stdin标准输入，以echo打印作为数据来源：</p>
<pre><code class="language-shell">&gt; echo -e &quot;1\n2\n3&quot; | clickhouse-local -q &quot;CREATE TABLE test_table (id Int64)  ENGINE = File(CSV, stdin); SELECT id FROM test_table;&quot;
1
2
3
</code></pre>
<p>也可以借助操作系统的命令，实现对系统用户内存用量的查询：</p>
<pre><code class="language-shell">&gt; ps aux | tail -n +2 | awk '{ printf(&quot;%s\t%s\n&quot;, $1, $4) }' | clickhouse-local -S &quot;user String, memory Float64&quot; -q &quot;SELECT user, round(sum(memory), 2) as memoryTotal FROM table GROUP BY user ORDER BY memoryTotal DESC FORMAT Pretty&quot;
┏----------┳-----------------------------┓
┃ user     ┃        memoryTotal          ┃
┡----------╇-----------------------------┩
│ nauu     │        42.7                 │
├──────────┼──────────----------------───┤
│ root     │        20.4                 │
├──────────┼─────────----------------────┤
│ clickho+ │         1.8                 │
└──────────┴────────----------------─────┘
</code></pre>
<p><strong>核心参数</strong>：</p>
<ul>
<li>
<p>（1）-S/--structure：表结构的简写方式，例如以下两种声明的效果是相同的。</p>
<pre><code class="language-shell">--使用-S简写
clickhouse-local -S &quot;id Int64&quot;
--使用DDL
clickhouse-local -q &quot;CREATE TABLE test_table (id Int64) ENGINE = File(CSV, stdin)&quot;
</code></pre>
</li>
<li>
<p>（2）-N/--table：表名称，默认值是table，例如下面的代码。</p>
<pre><code class="language-shell">clickhouse-local -S &quot;id Int64&quot; -N &quot;test_table&quot; -q &quot;SELECt id FROM test_table&quot;
</code></pre>
</li>
<li>
<p>（3）-if/--input-format：输入数据的格式，默认值是TSV，例如下面的代码。</p>
<pre><code class="language-shell">echo -e &quot;1\n2\n3&quot; | clickhouse-local -S &quot;id Int64&quot; -if &quot;CSV&quot; -N &quot;test_table&quot;
</code></pre>
</li>
<li>
<p>（4）-f/--file：输入数据的地址，默认值是stdin标准输入。</p>
</li>
<li>
<p>（5）-q/--query：待执行的SQL语句，多条语句之间以分号间隔。</p>
</li>
</ul>
<p>完整的参数列表可以通过--help查阅。</p>
<h2 id="clickhouse-benchmark"><a class="header" href="#clickhouse-benchmark">clickhouse-benchmark</a></h2>
<p>clickhouse-benchmark是基准测试的小工具，它可以自动运行SQL查询，并生成相应的运行指标报告，例如执行下面的语句启动测试：</p>
<pre><code class="language-shell">&gt; echo &quot;SELECT * FROM system.numbers LIMIT 100&quot; | clickhouse-benchmark -i 5
Loaded 1 queries.

# 执行之后，按照指定的参数该查询会执行5次：
Queries executed: 5.  

# 执行完毕后，会出具包含QPS、RPS等指标信息的报告：
127.0.0.1:9000, queries 5, QPS: 812.189, RPS: 81218.868, MiB/s: 0.620, result RPS: 81218.868, result MiB/s: 0.620.

# 还会出具各百分位的查询执行时间：
0.000%          0.001 sec.
10.000%         0.001 sec.
20.000%         0.001 sec.
30.000%         0.001 sec.
40.000%         0.001 sec.
50.000%         0.001 sec.
60.000%         0.001 sec.
70.000%         0.001 sec.
80.000%         0.001 sec.
90.000%         0.002 sec.
95.000%         0.002 sec.
99.000%         0.002 sec.
99.900%         0.002 sec.
99.990%         0.002 sec.

# 可以指定多条SQL进行测试，此时需要将SQL语句定义在文件中：
&gt; cat ./multi-sqls 
SELECT * FROM system.numbers LIMIT 100
SELECT * FROM system.numbers LIMIT 200

# 在multi-sqls文件内定义了两条SQL，按照定义的顺序它们会依次执行：
&gt; clickhouse-benchmark -i 5 &lt; ./multi-sqls
Loaded 2 queries.
……
</code></pre>
<p><strong>核心参数</strong>:</p>
<ul>
<li>
<p>（1）-i/--iterations：SQL查询执行的次数，默认值是0。</p>
</li>
<li>
<p>（2）-c/--concurrency：同时执行查询的并发数，默认值是1。</p>
</li>
<li>
<p>（3）-r/--randomize：在执行多条SQL语句的时候，按照随机顺序执行，例如:</p>
<pre><code class="language-shell">&gt; clickhouse-benchmark -r 1 -i 5  &lt; ./multi-sqls
</code></pre>
</li>
<li>
<p>（4）-h/--host：服务端地址，默认值是localhost。clickhouse-benchmark支持对比测试，此时需要通过此参数声明两个服务端的地址，例如:</p>
<pre><code class="language-shell">&gt; echo &quot;SELECT * FROM system.numbers LIMIT 100&quot; | clickhouse-benchmark -i 5 -h localhost -h localhost
Loaded 1 queries.

Queries executed: 5.

# 第一个服务
127.0.0.1:9000, queries 2, QPS: 878.703, RPS: 87870.258, MiB/s: 0.670, result RPS: 87870.258, result MiB/s: 0.670.
# 第二个服务
127.0.0.1:9000, queries 3, QPS: 748.210, RPS: 74820.972, MiB/s: 0.571, result RPS: 74820.972, result MiB/s: 0.571.

# 在对比测试中，clickhouse-benchmark会通过抽样的方式比较两组查询指标的差距，在默认的情况下，置信区间为99.5%：
0.000%          0.001 sec.      0.001 sec.
10.000%         0.001 sec.      0.001 sec.
20.000%         0.001 sec.      0.001 sec.
30.000%         0.001 sec.      0.001 sec.
40.000%         0.001 sec.      0.001 sec.
50.000%         0.001 sec.      0.001 sec.
60.000%         0.001 sec.      0.001 sec.
70.000%         0.001 sec.      0.001 sec.
80.000%         0.001 sec.      0.002 sec.
90.000%         0.001 sec.      0.002 sec.
95.000%         0.001 sec.      0.002 sec.
99.000%         0.001 sec.      0.002 sec.
99.900%         0.001 sec.      0.002 sec.
99.990%         0.001 sec.      0.002 sec.

No difference proven at 99.5% confidence
</code></pre>
</li>
<li>
<p>（5）--confidence：设置对比测试中置信区间的范围，默认值是5(99.5%)，它的取值范围有0(80%)、1(90%)、2(95%)、3(98%)、4(99%)和5(99.5%)。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据定义"><a class="header" href="#数据定义">数据定义</a></h1>
<p>ClickHouse提供了许多数据类型，它们可以划分为基础类型、复合类型和特殊类型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础数据类型"><a class="header" href="#基础数据类型">基础数据类型</a></h1>
<p>基础类型只有<code>数值</code>、<code>字符串</code>和<code>时间</code>三种类型，没有<code>Boolean</code>类型，但可以使用整型的<code>0</code>或<code>1</code>替代。</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_int.html#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B">数值类型</a>
<ul>
<li><a href="clickhouse/base_type_int.html#int">Int</a></li>
<li><a href="clickhouse/base_type_int.html#float">Float</a></li>
<li><a href="clickhouse/base_type_int.html#decimal">Decimal</a></li>
</ul>
</li>
</ul>
<h1 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h1>
<p>数值类型分为<code>整数</code>、<code>浮点数</code>和<code>定点数</code>三类.</p>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/int-uint/">https://clickhouse.com/docs/zh/sql-reference/data-types/int-uint/</a></p>
<p>创建表时，可以为整数设置类型参数 (例如. TINYINT(8), SMALLINT(16), INT(32), BIGINT(64)), 但 ClickHouse 会忽略它们.</p>
<p>有符号</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>范围</th><th>常用</th></tr></thead><tbody>
<tr><td>Int8</td><td>1</td><td>-128 - 127</td><td>Tinyint</td></tr>
<tr><td>Int16</td><td>2</td><td>-32768 - 32767</td><td>Smallint</td></tr>
<tr><td>Int32</td><td>4</td><td>-2147483648 - 2147483647</td><td>Int</td></tr>
<tr><td>Int64</td><td>8</td><td>-9223372036854775808 - 9223372036854775807</td><td>Bigint</td></tr>
<tr><td>Int128</td><td>16</td><td>-1701411834604692317... - 1701411834604692317...</td><td>-</td></tr>
<tr><td>Int256</td><td>32</td><td>-5789604461865809771... - 5789604461865809771...</td><td>-</td></tr>
</tbody></table>
<p>无符号</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>范围</th><th>常用</th></tr></thead><tbody>
<tr><td>UInt8</td><td>1</td><td>0 - 255</td><td>Tinyint Unsigned</td></tr>
<tr><td>UInt16</td><td>2</td><td>0 - 65535</td><td>Smallint Unsigned</td></tr>
<tr><td>UInt32</td><td>4</td><td>0 - 4294967295</td><td>Int Unsigned</td></tr>
<tr><td>UInt64</td><td>8</td><td>0 - 18446744073709551615</td><td>Bigint Unsigned</td></tr>
<tr><td>UInt128</td><td>16</td><td>0 - 340282366920938463463374607431768211455</td><td>-</td></tr>
<tr><td>UInt256</td><td>32</td><td>0 - 115792089237316195423570985008687907853...</td><td>-</td></tr>
</tbody></table>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/float/">https://clickhouse.com/docs/zh/sql-reference/data-types/float/</a></p>
<p>与整数类似，ClickHouse直接使用<code>Float32</code>和<code>Float64</code>代表单精度浮点数以及双精度浮点数</p>
<table><thead><tr><th>名称</th><th>大小(字节)</th><th>有效经度(位数)</th><th>常用</th></tr></thead><tbody>
<tr><td>Float32</td><td>4</td><td>7</td><td>Float</td></tr>
<tr><td>Float64</td><td>8</td><td>16</td><td>Double</td></tr>
</tbody></table>
<p>ClickHouse的浮点数支持正无穷、负无穷以及非数字的表达方式。</p>
<ul>
<li>
<p>Inf – 正无穷</p>
<pre><code class="language-sql">&gt;) SELECT 0.5 / 0
┌─divide(0.5, 0)─┐
│            inf │
└────────────────┘
</code></pre>
</li>
<li>
<p>-Inf – 负无穷</p>
<pre><code class="language-sql">&gt;) SELECT -0.5 / 0
┌─divide(-0.5, 0)─┐
│            -inf │
└─────────────────┘
</code></pre>
</li>
<li>
<p>NaN – 非数字</p>
<pre><code class="language-sql">&gt;) SELECT 0 / 0
┌─divide(0, 0)──┐
│            nan│
└───────────────┘
</code></pre>
</li>
</ul>
<h2 id="decimal"><a class="header" href="#decimal">Decimal</a></h2>
<p>参考官网: <a href="https://clickhouse.com/docs/zh/sql-reference/data-types/decimal/">https://clickhouse.com/docs/zh/sql-reference/data-types/decimal/</a></p>
<p>更高精度的数值运算，则需要使用定点数。ClickHouse提供了Decimal32、Decimal64和Decimal128三种精度的定点数。可以通过两种形式声明定点：简写方式有Decimal32(S)、Decimal64(S)、Decimal128(S)三种，原生方式为Decimal(P,S)，其中：</p>
<ul>
<li>P代表精度，决定总位数（整数部分+小数部分），取值范围是1～38；</li>
<li>S代表规模，决定小数位数，取值范围是0～P。</li>
</ul>
<p>对应关系：</p>
<table><thead><tr><th>名称</th><th>有效声明</th><th>范围</th></tr></thead><tbody>
<tr><td>Decimal32(S)</td><td>Decimal(1 ~ 9 , S)</td><td>-1 * 10<sup>^</sup>(9-S) 至  10<sup>^</sup>(9-S)</td></tr>
<tr><td>Decimal64(S)</td><td>Decimal(10 ~ 18 , S)</td><td>-1 * 10<sup>^</sup>(18-S) 至  10<sup>^</sup>(18-S)</td></tr>
<tr><td>Decimal128(S)</td><td>Decimal(19 ~ 38 , S)</td><td>-1 * 10<sup>^</sup>(38-S) 至  10<sup>^</sup>(38-S)</td></tr>
</tbody></table>
<p>由于现代CPU不支持128位数字，因此 <code>Decimal128</code> 上的操作由软件模拟。所以 <code>Decimal128</code> 的运算速度明显慢于 <code>Decimal32</code>/<code>Decimal64</code>。</p>
<p><strong>对Decimal的二进制运算导致更宽的结果类型（无论参数的顺序如何）。</strong></p>
<ul>
<li>Decimal64(S1) &lt;op&gt; Decimal32(S2) -&gt; Decimal64(S)</li>
<li>Decimal128(S1) &lt;op&gt; Decimal32(S2) -&gt; Decimal128(S)</li>
<li>Decimal128(S1) &lt;op&gt; Decimal64(S2) -&gt; Decimal128(S)</li>
</ul>
<p><strong>精度变化的规则：</strong></p>
<ul>
<li>加法，减法：S = max(S1, S2)。</li>
<li>乘法：S = S1 + S2。</li>
<li>除法：S = S1。</li>
</ul>
<p>例如<code>toDecimal64(2,4)</code>与<code>toDecimal32(2,2)</code>相加或相减后<code>S=4</code>：</p>
<pre><code class="language-shell"># 相加
:) SELECT toDecimal64(2,4) + toDecimal32(2,2)
 
┌─plus(toDecimal64(2, 4), toDecimal32(2, 2))─┐
│ 4.0000                                     │ # 保留四位
└────────────────────────────────────────────┘

# 相减
:) SELECT toDecimal32(4,4) - toDecimal64(2,2)

┌─minus(toDecimal32(4, 4), toDecimal64(2, 2))┐
│ 2.0000                                     │ # 保留四位
└────────────────────────────────────────────┘

# toDecimal64(2,4)与toDecimal32(2,2)相乘后S=4+2=6
:) SELECT toDecimal64(2,4) * toDecimal32(2,2)

┌─multiply(toDecimal64(2, 4), toDecimal32(2, 2))┐
│ 4.000000                                      │
└───────────────────────────────────────────────┘

# toDecimal64(2,4)与toDecimal32(2,2)相除后S=4
:) SELECT toDecimal64(2,4) / toDecimal32(2,2)

┌─divide(toDecimal64(2, 4), toDecimal32(2, 2))─┐
│  1.0000                                      │
└──────────────────────────────────────────────┘

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_string.html#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">字符串类型</a>
<ul>
<li><a href="clickhouse/base_type_string.html#string">String</a></li>
<li><a href="clickhouse/base_type_string.html#fixedstring">FixedString</a></li>
<li><a href="clickhouse/base_type_string.html#uuid">UUID</a></li>
</ul>
</li>
</ul>
<h1 id="字符串类型"><a class="header" href="#字符串类型">字符串类型</a></h1>
<p>字符串类型可以细分为<code>String</code>、<code>FixedString</code>和<code>UUID</code>三类</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>字符串由String定义，长度不限。因此在使用String的时候无须声明大小。它完全代替了传统意义上数据库的Varchar、Text、Clob和Blob等字符类型。String类型不限定字符集，因为它根本就没有这个概念，所以可以将任意编码的字符串存入其中。但是为了程序的规范性和可维护性，在同一套程序中应该遵循使用统一的编码，例如“统一保持UTF-8编码”就是一种很好的约定。</p>
<h2 id="fixedstring"><a class="header" href="#fixedstring">FixedString</a></h2>
<p>FixedString类型和传统意义上的Char类型有些类似，对于一些字符有明确长度的场合，可以使用固定长度的字符串。定长字符串通过FixedString(N)声明，其中N表示字符串长度。但与Char不同的是，FixedString使用null字节填充末尾字符，而Char通常使用空格填充。比如在下面的例子中，字符串‘abc’虽然只有3位，但长度却是5，因为末尾有2位空字符填充：</p>
<pre><code class="language-sql">:) SELECT toFixedString('abc',5) , LENGTH(toFixedString('abc',5)) AS LENGTH

┌─toFixedString('abc', 5)─┬─LENGTH──────┐
│ abc                     │ 5           │
└─────────────────────────┴─────────────┘
</code></pre>
<h2 id="uuid"><a class="header" href="#uuid">UUID</a></h2>
<p>UUID是一种数据库常见的主键类型，在ClickHouse中直接把它作为一种数据类型。UUID共有32位，它的格式为8-4-4-4-12。如果一个UUID类型的字段在写入数据时没有被赋值，则会依照格式使用0填充，例如：</p>
<pre><code class="language-sql">
CREATE TABLE UUID_TEST (
  c1 UUID,
  c2 String
) ENGINE = Memory;

--第一行UUID有值
INSERT INTO UUID_TEST SELECT generateUUIDv4(),'t1'
--第二行UUID没有值
INSERT INTO UUID_TEST(c2) VALUES ('t2')

:) SELECT * FROM UUID_TEST
┌─────────────────────c1─┬─c2─┐
│ f36c709e-1b73-4370-a703-f486bdd22749 │ t1 │
└───────────────────────┴────┘
┌─────────────────────c1─┬─c2─┐
│ 00000000-0000-0000-0000-000000000000 │ t2 │
└───────────────────────┴────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/base_type_datetime.html#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B">时间类型</a>
<ul>
<li><a href="clickhouse/base_type_datetime.html#datetime">DateTime</a></li>
<li><a href="clickhouse/base_type_datetime.html#datetime64">DateTime64</a></li>
<li><a href="clickhouse/base_type_datetime.html#date">Date</a></li>
<li><a href="clickhouse/base_type_datetime.html#date32">Date32</a></li>
</ul>
</li>
</ul>
<h1 id="时间类型"><a class="header" href="#时间类型">时间类型</a></h1>
<p>时间类型分为<code>DateTime</code>、<code>DateTime64</code>、<code>Date</code>、<code>Date32</code>四类。ClickHouse目前没有时间戳类型。</p>
<p>时间类型最高的精度是秒，也就是说，如果需要处理毫秒、微秒等大于秒分辨率的时间，则只能借助<code>UInt</code>类型实现.</p>
<h2 id="datetime"><a class="header" href="#datetime">DateTime</a></h2>
<p>DateTime类型包含时、分、秒信息，精确到秒，支持使用字符串形式写入：</p>
<pre><code class="language-sql">CREATE TABLE Datetime_TEST (
    c1 Datetime
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Datetime_TEST VALUES('2019-06-22 00:00:00')
 
 SELECT c1, toTypeName(c1) FROM Datetime_TEST

┌──────────c1─┬─toTypeName(c1)───────────┐
│ 2019-06-22 00:00:00 │  DateTime        │
└─────────────────────┴──────────────────┘
</code></pre>
<h2 id="datetime64"><a class="header" href="#datetime64">DateTime64</a></h2>
<p>DateTime64可以记录亚秒，它在DateTime之上增加了精度的设置，例如：</p>
<pre><code class="language-sql">CREATE TABLE Datetime64_TEST (
    c1 Datetime64(2)    
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Datetime64_TEST VALUES('2019-06-22 00:00:00')
 
SELECT c1, toTypeName(c1) FROM Datetime64_TEST

┌─────────────c1─┬─toTypeName(c1)─────────┐
│ 2019-06-22 00:00:00.00 │ DateTime       │
└────────────────────────┴────────────────┘
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>Date类型不包含具体的时间信息，只精确到天，它同样也支持字符串形式写入：</p>
<pre><code class="language-sql">CREATE TABLE Date_TEST (
  c1 Date
) ENGINE = Memory

--以字符串形式写入
INSERT INTO Date_TEST VALUES('2019-06-22')

SELECT c1, toTypeName(c1) FROM Date_TEST

┌─────────c1─┬─toTypeName(c1)────────┐
│ 2019-06-22       │ Date            │
└──────────────────┴─────────────────┘

</code></pre>
<h2 id="date32"><a class="header" href="#date32">Date32</a></h2>
<blockquote>
<p>注意: <a href="https://clickhouse.com/docs/zh/whats-new/changelog/#clickhouse-release-v22-1-2022-01-18">v22.1</a>版本中新增支持。</p>
</blockquote>
<p>一个日期。 支持与 <a href="clickhouse/base_type_datetime.html#datetime64">Datetime64</a> 相同的日期范围。 存储自 <code>1925-01-01</code> 以来的天数，占用4个字节。 允许将日期存储到<code>2283-11-11</code>。</p>
<pre><code class="language-sql">CREATE TABLE Date32_TEST ( c1 Date32 ) ENGINE = Memory

--以字符串形式写入
INSERT INTO Date32_TEST VALUES('2282-06-22')

SELECT c1, toTypeName(c1) FROM Date32_TEST

┌─────────c1─┬─toTypeName(c1)────────┐
│ 2282-06-22       │ Date32          │
└──────────────────┴─────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复合数据类型"><a class="header" href="#复合数据类型">复合数据类型</a></h1>
<p>除了基础数据类型之外，ClickHouse还提供了数组、元组、枚举和嵌套四类复合类型。这些类型通常是其他数据库原生不具备的特性。拥有了复合类型之后，ClickHouse的数据模型表达能力更强了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p><strong>数组有两种定义形式</strong></p>
<ul>
<li>
<p>常规方式array(T)</p>
<pre><code class="language-sql">SELECT array(1, 2) as a , toTypeName(a)
┌─a─────┬─toTypeName(array(1, 2))─┐
│ [1,2] │ Array(UInt8)            │
└───────┴─────────────────────────┘
</code></pre>
</li>
<li>
<p>简写方式[T]:</p>
<pre><code class="language-sql">SELECT [1, 2]
</code></pre>
</li>
</ul>
<p>因为ClickHouse的数组拥有类型推断的能力, 所以在查询时并不需要主动声明数组的元素类型。</p>
<p>推断依据：以最小存储代价为原则，即使用最小可表达的数据类型。</p>
<p>例如在例子中，<code>array(1,2)</code>会通过自动推断将<code>UInt8</code>作为数组类型。但是数组元素中如果存在<code>Null</code>值，则元素类型将变为<code>Nullable</code>，例如：</p>
<pre><code class="language-sql">SELECT [1, 2, null] as a , toTypeName(a)
┌─a──────┬─toTypeName([1, 2, NULL])────┐
│ [1,2,NULL] │ Array(Nullable(UInt8))  │
└────────┴─────────────────────────────┘
</code></pre>
<p>在同一个数组内可以包含多种数据类型，例如数组<code>[1,2.0]</code>是可行的。但各类型之间必须兼容，例如数组<code>[1,'2']</code>则会报错。</p>
<p>在定义表字段时，数组需要指定明确的元素类型，例如：</p>
<pre><code class="language-sql">CREATE TABLE Array_TEST (
  c1 Array(String)
) engine = Memory
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组类型由<code>1～n</code>个元素组成，每个元素之间允许设置不同的数据类型，且彼此之间不要求兼容。</p>
<p>元组同样支持类型推断，其推断依据仍然以最小存储代价为原则。</p>
<p>与数组类似，元组也可以使用两种方式定义:</p>
<ul>
<li>
<p><strong>常规方式</strong><code>tuple(T)</code>：</p>
<pre><code class="language-sql">
SELECT tuple(1,'a',now()) AS x, toTypeName(x)
┌─x─────────────────────────────┬─toTypeName(tuple(1, 'a', now()))──┐
│ (1,'a','2019-08-28 21:36:32') │ Tuple(UInt8, String, DateTime)    │
└───────────────────────────────┴───────────────────────────────────┘
</code></pre>
</li>
<li>
<p><strong>简写方式（T）</strong>:</p>
</li>
</ul>
<pre><code class="language-sql">SELECT (1,2.0,null) AS x, toTypeName(x)
┌─x────────────┬─toTypeName(tuple(1, 2., NULL))───────────┐
│ (1,2,NULL)   │ Tuple(UInt8, Float64, Nullable(Nothing)) │
└──────────────┴──────────────────────────────────────────┘
</code></pre>
<p>在定义表字段时，元组需要指定明确的元素类型：</p>
<pre><code class="language-sql">CREATE TABLE Tuple_TEST (
  c1 Tuple(String,Int8)
) ENGINE = Memory;
</code></pre>
<p>元素类型和泛型的作用类似，可以进一步保障数据质量。在数据写入的过程中会进行类型检查。</p>
<p>例如，写入<code>INSERT INTO Tuple_TEST VALUES(('abc',123))</code>是可行的，而写入<code>INSERT INTO Tuple_TEST VALUES(('abc','efg'))</code>则会报错。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举"><a class="header" href="#枚举">枚举</a></h1>
<p>ClickHouse支持枚举类型，这是一种在定义常量时经常会使用的数据类型。</p>
<p>ClickHouse提供了<code>Enum8</code>和<code>Enum16</code>两种枚举类型，它们除了取值范围不同之外，别无二致。</p>
<p>枚举固定使用 (String:Int) Key/Value键值对的形式定义数据，</p>
<p>所以<code>Enum8</code>和<code>Enum16</code>分别会对应<code>(String:Int8)</code>和<code>(String:Int16)</code>，例如：</p>
<pre><code class="language-sql">CREATE TABLE Enum_TEST (
    c1 Enum8('ready' = 1, 'start' = 2, 'success' = 3, 'error' = 4)
) ENGINE = Memory;
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>Key和Value是不允许重复的，要保证唯一性。</p>
</li>
<li>
<p>Key和Value的值都不能为Null，但Key允许是空字符串</p>
</li>
</ul>
<p>在写入枚举数据的时候，只会用到Key字符串部分，例如：</p>
<pre><code class="language-sql">INSERT INTO Enum_TEST VALUES('ready');
INSERT INTO Enum_TEST VALUES('start');
</code></pre>
<p>数据在写入的过程中，会对照枚举集合项的内容逐一检查。如果Key字符串不在集合范围内则会抛出异常，比如执行下面的语句就会出错：</p>
<pre><code class="language-sql">INSERT INTO Enum_TEST VALUES('stop');
</code></pre>
<p>枚举完全可以使用String代替枚举，为什么还需要专门的枚举类型呢？</p>
<p>这是出于性能的考虑。因为虽然枚举定义中的Key属于String类型，但是在后续对枚举的所有操作中（包括排序、分组、去重、过滤等），会使用Int类型的Value值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌套"><a class="header" href="#嵌套">嵌套</a></h1>
<p>嵌套类型，顾名思义是一种嵌套表结构。</p>
<p>一张数据表，可以定义任意多个嵌套类型字段，但每个字段的嵌套层级只支持一级，即嵌套表内不能继续使用嵌套类型。</p>
<p>对于简单场景的层级关系或关联关系，使用嵌套类型也是一种不错的选择。</p>
<p>例如，下面的nested_test是一张模拟的员工表，它的所属部门字段就使用了嵌套类型：</p>
<pre><code class="language-sql">CREATE TABLE nested_test (
  name String,
  age  UInt8 ,
  dept Nested(
  id UInt8,
  name String
)
) ENGINE = Memory;
</code></pre>
<p>ClickHouse的嵌套类型和传统的嵌套类型不相同，导致在初次接触它的时候会让人十分困惑。以上面这张表为例，如果按照它的字面意思来理解，会很容易理解成nested_test与dept是一对一的包含关系，其实这是错误的。不信可以执行下面的语句，看看会是什么结果：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('nauu',18, 10000, '研发部');
Exception on client:
Code: 53. DB::Exception: Type mismatch in IN or VALUES section. Expected: Array(UInt8). Got: UInt64
</code></pre>
<p>注意上面的异常信息，它提示期望写入的是一个Array数组类型。</p>
<p><strong>嵌套类型本质是一种多维数组的结构。嵌套表中的每个字段都是一个数组，同一行数据中数据必须对其，但行与行之间数组的长度无须对齐。</strong></p>
<p>所以需要把刚才的INSERT语句调整成下面的形式：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001,10002], ['研发部','技术支持中心','测试部']);
--行与行之间,数组长度无须对齐
INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001], ['研发部','技术支持中心']);
</code></pre>
<p>需要注意的是，在同一行数据内每个数组字段的长度必须相等。例如，在下面的示例中，由于行内数组字段的长度没有对齐，所以会抛出异常：</p>
<pre><code class="language-sql">INSERT INTO nested_test VALUES ('bruce' , 30 , [10000,10001], ['研发部','技术支持中心', '测试部']); 
DB::Exception: Elements 'dept.id' and 'dept.name' of Nested data structure 'dept' (Array columns) have different array sizes..
</code></pre>
<p>在访问嵌套类型的数据时需要使用点符号，例如：</p>
<pre><code class="language-sql">SELECT name, dept.id, dept.name FROM nested_test

┌─name──┬─dept.id────┬────dept.name───────────────────┐
│ bruce │ [16,17,18] │ ['研发部','技术支持中心','测试部'] │
└───────┴────────────┴────────────────────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特殊类型"><a class="header" href="#特殊类型">特殊类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nullable"><a class="header" href="#nullable">Nullable</a></h1>
<p>原文：<a href="https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/">https://clickhouse.com/docs/zh/sql-reference/data-types/nullable/</a></p>
<p>准确来说，Nullable并不能算是一种独立的数据类型，它更像是一种辅助的修饰符，需要与基础数据类型一起搭配使用。</p>
<p>Nullable类型与Java8的Optional对象有些相似，它表示某个基础数据类型可以是Null值。</p>
<pre><code class="language-sql">CREATE TABLE Null_TEST (
  c1 String,
  c2 Nullable(UInt8)
) ENGINE = TinyLog;

- 通过Nullable修饰后c2字段可以被写入Null值：

INSERT INTO Null_TEST VALUES ('nauu',null)
INSERT INTO Null_TEST VALUES ('bruce',20)

SELECT c1 , c2 ,toTypeName(c2) FROM Null_TEST

┌───c1───┬────c2───┬──toTypeName(c2)─┐
│ nauu   │ NULL    │ Nullable(UInt8) │
│ bruce  │ 20      │ Nullable(UInt8) │
└────────┴─────────┴─────────────────┘
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>
<p>它只能和基础类型搭配使用，不能用于数组和元组这些复合类型，也不能作为索引字段</p>
</li>
<li>
<p>慎用Nullable类型，包括Nullable的数据表，不然会使查询和写入性能变慢。【因为在正常情况下，每个列字段的数据会被存储在对应的[Column].bin文件中。如果一个列字段被Nullable类型修饰后，会额外生成一个[Column].null.bin文件专门保存它的Null值。这意味着在读取和写入数据时，需要一倍的额外文件操作。】</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domain"><a class="header" href="#domain">Domain</a></h1>
<p>域名类型分为IPv4和IPv6两类，本质上它们是对整型和字符串的进一步封装。IPv4类型是基于UInt32封装的。</p>
<pre><code class="language-sql">CREATE TABLE IP4_TEST (
  url String,
  ip IPv4
) ENGINE = Memory;

INSERT INTO IP4_TEST VALUES ('www.nauu.com','192.0.0.0')

SELECT url , ip ,toTypeName(ip) FROM IP4_TEST

┌─url──────────┬─────ip────┬─toTypeName(ip)───────┐
│ www.nauu.com │ 192.0.0.0 │     IPv4             │
└──────────────┴───────────┴──────────────────────┘
</code></pre>
<p>直接使用字符串不就行了吗？</p>
<ul>
<li>
<p>（1）出于便捷性的考量，例如IPv4类型支持格式检查，格式错误的IP数据是无法被写入的，例如：</p>
<pre><code class="language-sql">INSERT INTO IP4_TEST VALUES ('www.nauu.com','192.0.0')
Code: 441. DB::Exception: Invalid IPv4 value.
</code></pre>
</li>
<li>
<p>（2）出于性能的考量，同样以IPv4为例，IPv4使用UInt32存储，相比String更加紧凑，占用的空间更小，查询性能更快。IPv6类型是基于FixedString(16)封装的，它的使用方法与IPv4别无二致.</p>
</li>
</ul>
<p>在使用Domain类型的时候还有一点需要注意，虽然它从表象上看起来与String一样，但Domain类型并不是字符串，所以它不支持隐式的自动类型转换。</p>
<p>如果需要返回IP的字符串形式，则需要显式调用<a href="https://clickhouse.com/docs/en/sql-reference/functions/ip-address-functions/#ipv4numtostringnum">IPv4NumToString</a>或<a href="https://clickhouse.com/docs/en/sql-reference/functions/ip-address-functions/#ipv6numtostringx">IPv6NumToString</a>函数进行转换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="定义数据表"><a class="header" href="#定义数据表">定义数据表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库"><a class="header" href="#数据库">数据库</a></h1>
<p>数据库起到了命名空间的作用，可以有效规避命名冲突的问题，也为后续的数据隔离提供了支撑。</p>
<p>任何一张数据表，都必须归属在某个数据库之下。</p>
<p>创建数据库的完整语法如下所示：</p>
<pre><code class="language-sql">CREATE DATABASE IF NOT EXISTS db_name [ENGINE = engine]
</code></pre>
<p>其中，<code>IF NOT EXISTS</code>表示如果已经存在一个同名的数据库，则会忽略后续的创建过程；<code>[ENGINE=engine]</code>表示数据库所使用的引擎类型.</p>
<p>数据库目前一共支持5种引擎，如下所示。</p>
<ul>
<li><strong>Ordinary</strong>：默认引擎，在绝大多数情况下我们都会使用默认引擎，使用时无须刻意声明。在此数据库下可以使用任意类型的表引擎。</li>
<li><strong>Dictionary</strong>：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表，关于数据字典的详细介绍会在第5章展开。</li>
<li><strong>Memory</strong>：内存引擎，用于存放临时数据。此类数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除。</li>
<li><strong>Lazy</strong>：日志引擎，此类数据库下只能使用Log系列的表引擎，关于Log表引擎的详细介绍会在第8章展开。</li>
<li><strong>MySQL</strong>：MySQL引擎，此类数据库下会自动拉取远端MySQL中的数据，并为它们创建MySQL表引擎的数据表。</li>
</ul>
<p>在绝大多数情况下都只需使用默认的数据库引擎。例如执行下面的语句，即能够创建属于我们的第一个数据库：</p>
<pre><code class="language-sql">CREATE DATABASE DB_TEST
</code></pre>
<p>默认数据库的实质是物理磁盘上的一个文件目录，所以在语句执行之后，ClickHouse便会在安装路径下创建DB_TEST数据库的文件目录：</p>
<pre><code class="language-shell"># pwd
/chbase/data
# ls
DB_TEST  default  system
</code></pre>
<p>与此同时，在metadata路径下也会一同创建用于恢复数据库的DB_TEST.sql文件：</p>
<pre><code class="language-shell"># pwd
/chbase/data/metadata
# ls
DB_TEST  DB_TEST.sql  default  system
</code></pre>
<p>使用SHOW DATABASES查询，即能够返回ClickHouse当前的数据库列表：</p>
<pre><code class="language-shell">SHOW DATABASES
┌─name──────┐
│  DB_TEST  │
│  default  │
│  system   │
└───────────┘
</code></pre>
<p>使用USE查询可以实现在多个数据库之间进行切换，而通过SHOW TABLES查询可以查看当前数据库的数据表列表。删除一个数据库，则需要用到下面的DROP查询。</p>
<pre><code class="language-sql">DROP DATABASE [IF EXISTS] db_name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据表"><a class="header" href="#数据表">数据表</a></h1>
<p>ClickHouse目前提供了三种最基本的建表方法。</p>
<p><strong>常规定义方法</strong></p>
<blockquote>
<p>语法：</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] [db_name.]table_name (
    name1 [type] [DEFAULT|MATERIALIZED|ALIAS expr],
    name2 [type] [DEFAULT|MATERIALIZED|ALIAS expr],
    省略…
) ENGINE = engine
</code></pre>
<p>使用[db_name.]参数可以为数据表指定数据库，如果不指定此参数，则默认会使用default数据库:</p>
<pre><code class="language-sql">CREATE TABLE hits_v1 ( 
  Title String,
  URL String ,
  EventTime DateTime
) ENGINE = Memory;
</code></pre>
<p>末尾的<code>ENGINE</code>参数，它被用于指定数据表的引擎。<strong><code>表引擎</code>决定了数据表的特性，也决定了数据将会被如何存储及加载。</strong></p>
<p>示例中使用的Memory表引擎，是ClickHouse最简单的表引擎，数据只会被保存在内存中，在服务重启时数据会丢失。</p>
</blockquote>
<p><strong>复制其他表的结构</strong></p>
<blockquote>
<p>语法：</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] [db_name1.]table_name AS [db_name2.] table_name2 [ENGINE = engine]
</code></pre>
<p>这种方式支持在不同的数据库之间复制表结构</p>
<pre><code class="language-sql">--创建新的数据库
CREATE DATABASE IF NOT EXISTS new_db 
--将default.hits_v1的结构复制到new_db.hits_v1
CREATE TABLE IF NOT EXISTS new_db.hits_v1 AS default.hits_v1 ENGINE = TinyLog
</code></pre>
<p>上述语句将会把<code>default.hits_v1</code>的表结构原样复制到<code>new_db.hits_v1</code>，并且ENGINE表引擎可以与原表不同</p>
</blockquote>
<p><strong>通过SELECT子句创建</strong></p>
<blockquote>
<p>语法：</p>
<pre><code class="language-sql">CREATE TABLE [IF NOT EXISTS] [db_name.]table_name ENGINE = engine AS SELECT …
</code></pre>
<p>在这种方式下，不仅会根据SELECT子句建立相应的表结构，同时还会将SELECT子句查询的数据顺带写入, 例如：</p>
<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS hits_v1_1 ENGINE = Memory AS SELECT * FROM hits_v1
</code></pre>
</blockquote>
<p><strong>DESC查询</strong></p>
<blockquote>
<p>ClickHouse和大多数数据库一样，使用DESC查询可以返回数据表的定义结构。</p>
<pre><code class="language-sql">:) desc hits_v1

DESCRIBE TABLE  hits_v1

Query id: eaa69aa2-5cd9-4ff8-9b70-7f0960aa33d8

┌─name──────┬─type─────┬─default_type─┬─default_expression─┬─comment─┬─codec_expression─┬─ttl_expression─┐
│ Title     │ String   │              │                    │         │                  │                │
│ URL       │ String   │              │                    │         │                  │                │
│ EventTime │ DateTime │              │                    │         │                  │                │
└───────────┴──────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────┘

3 rows in set. Elapsed: 0.001 sec.
</code></pre>
</blockquote>
<p><strong>DROP删除表</strong></p>
<blockquote>
<p>如果想删除一张数据表，则可以使用下面的DROP语句：</p>
<pre><code class="language-sql">DROP TABLE [IF EXISTS] [db_name.]table_name
</code></pre>
<pre><code class="language-sql">:) DROP　table default.hits_v1

DROP TABLE default.hits_v1

Query id: 2deeda6b-9922-41c9-b2af-5e8e3efbddfe

Ok.

0 rows in set. Elapsed: 0.002 sec.
</code></pre>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字段默认值表达式"><a class="header" href="#字段默认值表达式">字段默认值表达式</a></h1>
<p>表字段支持三种默认值表达式的定义方法，分别是<code>DEFAULT</code>、<code>MATERIALIZED</code>和<code>ALIAS</code>。</p>
<p>无论使用哪种形式，表字段一旦被定义了默认值，它便不再强制要求定义数据类型，因为ClickHouse会根据默认值进行类型推断。</p>
<p>如果同时对表字段定义了数据类型和默认值表达式，则以明确定义的数据类型为主，例如:</p>
<pre><code class="language-sql">CREATE TABLE dfv_v1 ( 
  id String,
  c1 DEFAULT 1000,  -- c1字段没有定义数据类型，默认值为整型1000；
  c2 String DEFAULT c1  -- c2字段定义了数据类型和默认值，且默认值等于c1, 由于同时定义了数据类型和默认值，所以它最终的数据类型来自明确定义的String。
) ENGINE = TinyLog
</code></pre>
<p>现在写入测试数据：</p>
<pre><code class="language-sql">INSERT INTO dfv_v1(id) VALUES ('A000')
</code></pre>
<p>在写入之后执行以下查询：</p>
<pre><code class="language-sql">:) SELECT c1, c2, toTypeName(c1), toTypeName(c2) from dfv_v1

Query id: 2508b947-02c8-4676-baca-658d90af2765

┌───c1─┬─c2───┬─toTypeName(c1)─┬─toTypeName(c2)─┐
│ 1000 │ 1000 │ UInt16         │ String         │
└──────┴──────┴────────────────┴────────────────┘

1 rows in set. Elapsed: 0.002 sec.
</code></pre>
<p>默认值表达式的三种定义方法之间也存在着不同之处:</p>
<ul>
<li>
<p><strong>数据写入</strong>：在数据写入时，只有<code>DEFAULT类型</code>的字段可以出现在<code>INSERT语句</code>中。而<code>MATERIALIZED</code>和<code>ALIAS</code>都不能被显式赋值，它们只能依靠计算取值。例如试图为<code>MATERIALIZED类型</code>的字段写入数据，将会得到如下的错误。</p>
<pre><code class="language-sql">DB::Exception: Cannot insert column URL, because it is MATERIALIZED column..
</code></pre>
</li>
<li>
<p><strong>数据查询</strong>：在数据查询时，只有<code>DEFAULT类型</code>的字段可以通过<code>SELECT *</code>返回。而<code>MATERIALIZED</code>和<code>ALIAS</code>类型的字段不会出现在<code>SELECT*</code>查询的返回结果集中。</p>
</li>
<li>
<p><strong>数据存储</strong>：在数据存储时，只有<code>DEFAULT</code>和<code>MATERIALIZED类型</code>的字段才支持持久化。如果使用的表引擎支持物理存储（例如TinyLog表引擎），那么这些列字段将会拥有物理存储。而<code>ALIAS类型</code>的字段不支持持久化，它的取值总是需要依靠计算产生，数据不会落到磁盘。</p>
</li>
</ul>
<p><strong>使用ALTER语句修改默认值</strong></p>
<pre><code class="language-sql">ALTER TABLE [db_name.]table MODIFY COLUMN col_name DEFAULT value
</code></pre>
<p><strong>修改动作并不会影响数据表内先前已经存在的数据。但是默认值的修改有诸多限制</strong>，例如在合并树表引擎中，它的主键字段是无法被修改的；而某些表引擎则完全不支持修改（例如TinyLog）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="临时表"><a class="header" href="#临时表">临时表</a></h1>
<p>ClickHouse也有临时表的概念，创建临时表的方法是在普通表的基础之上添加TEMPORARY关键字.</p>
<p>语法：</p>
<pre><code class="language-sql">CREATE TEMPORARY TABLE [IF NOT EXISTS] table_name (
    name1 [type] [DEFAULT|MATERIALIZED|ALIAS expr],
    name2 [type] [DEFAULT|MATERIALIZED|ALIAS expr],
)
</code></pre>
<p>两点特殊之处:</p>
<ul>
<li>它的生命周期是会话绑定的，所以它只支持Memory表引擎，如果会话结束，数据表就会被销毁；</li>
<li>临时表不属于任何数据库，所以在它的建表语句中，既没有数据库参数也没有表引擎参数。</li>
</ul>
<blockquote>
<p>如果临时表和普通表名称相同，会出现什么状况呢？</p>
<p>临时表的优先级是大于普通表的。当两张数据表名称相同的时候，会优先读取临时表的数据。</p>
</blockquote>
<p>在ClickHouse的日常使用中，通常不会刻意使用临时表。它更多被运用在ClickHouse的内部，是数据在集群间传播的载体。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分区表"><a class="header" href="#分区表">分区表</a></h1>
<p>数据分区（partition）和数据分片（shard）是完全不同的两个概念。</p>
<p>数据分区是针对本地数据而言的，是数据的一种纵向切分; 而数据分片是数据的一种横向切分。</p>
<p>数据分区对于一款OLAP数据库而言意义非凡：借助数据分区，在后续的查询过程中能够跳过不必要的数据目录，从而提升查询的性能。</p>
<p>合理地利用分区特性，还可以变相实现数据的更新操作，因为数据分区支持删除、替换和重置操作。</p>
<p>假设数据表按照月份分区，那么数据就可以按月份的粒度被替换更新。</p>
<p>分区虽好，但不是所有的表引擎都可以使用这项特性，目前只有合并树（<code>MergeTree</code>）家族系列的表引擎才支持数据分区。</p>
<p>创建表时，由<code>PARTITION BY</code>指定分区键，例如使用了日期字段作为分区键，并将其格式化为年月的形式:</p>
<pre><code class="language-sql">CREATE TABLE partition_v1 ( 
  ID String,
  URL String,
  EventTime Date
) ENGINE =  MergeTree()
PARTITION BY toYYYYMM(EventTime) 
ORDER BY ID
</code></pre>
<p>接着写入不同月份的测试数据：</p>
<pre><code class="language-sql">INSERT INTO partition_v1 VALUES 
('A000','www.nauu.com', '2019-05-01'),
('A001','www.brunce.com', '2019-06-02')
</code></pre>
<p>最后通过<code>system.parts</code>系统表，查询数据表的分区状态：</p>
<pre><code class="language-sql">SELECT table,partition,path from system.parts WHERE table = 'partition_v1' 
┌─table────────┬──partition─┬─path───────────────────────────────────────────┐
│ partition_v1 │ 201905     │ /chbase/data/default/partition_v1/201905_1_1_0/│
│ partition_v1 │ 201906     │ /chbase/data/default/partition_v1/201906_2_2_0/│
└──────────────┴────────────┴────────────────────────────────────────────────┘
</code></pre>
<blockquote>
<p>partition_v1按年月划分后，目前拥有两个数据分区，且每个分区都对应一个独立的文件目录，用于保存各自部分的数据。</p>
</blockquote>
<p><strong>合理设计分区键非常重要，通常会按照数据表的查询场景进行针对性设计。</strong></p>
<p>例如：</p>
<pre><code class="language-sql">SELECT * FROM  partition_v1 WHERE EventTime ='2019-05-01'
</code></pre>
<p>那么在后续的查询过程中，可以利用分区索引跳过6月份的分区目录，只加载5月份的数据，从而带来查询的性能提升。</p>
<p>当然，使用不合理的分区键也会适得其反，分区键不应该使用粒度过细的数据字段。例如，按照小时分区，将会带来分区数量的急剧增长，从而导致性能下降。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="视图"><a class="header" href="#视图">视图</a></h1>
<p>参考原文: <a href="https://clickhouse.com/docs/zh/sql-reference/statements/create/view/">CREATE VIEW</a></p>
<p>ClickHouse拥有普通和物化两种视图，其中物化视图拥有独立的存储，而普通视图只是一层简单的查询代理。</p>
<p>语法:</p>
<pre><code class="language-sql">CREATE VIEW [IF NOT EXISTS] [db_name.]view_name AS SELECT ...
</code></pre>
<p>普通视图不会存储任何数据，它只是一层单纯的SELECT查询映射，起着简化查询、明晰语义的作用，对查询性能不会有任何增强。</p>
<p>假设有一张普通视图view_tb_v1，它是基于数据表tb_v1创建的，那么下面的两条SELECT查询是完全等价的：</p>
<pre><code class="language-sql">--普通表
SELECT * FROM tb_v1
-- tb_v1的视图
SELECT * FROM view_tb_v1
</code></pre>
<p>物化视图支持表引擎，数据保存形式由它的表引擎决定，创建物化视图的完整语法如下所示：</p>
<pre><code class="language-sql">CREATE [MATERIALIZED] VIEW [IF NOT EXISTS] [db.]table_name [TO[db.]name] [ENGINE = engine] [POPULATE] AS SELECT ...
</code></pre>
<p><strong>物化视图创建好之后，如果源表被写入新数据，那么物化视图也会同步更新。</strong></p>
<p><strong>POPULATE修饰符决定了物化视图的初始化策略：</strong></p>
<ul>
<li>
<p>如果使用了POPULATE修饰符，那么在创建视图的过程中，会连带将源表中已存在的数据一并导入，如同执行了SELECT INTO一般；</p>
</li>
<li>
<p>如果不使用POPULATE修饰符，那么物化视图在创建之后是没有数据的，它只会同步在此之后被写入源表的数据。</p>
</li>
</ul>
<p><strong>物化视图目前并不支持同步删除，如果在源表中删除了数据，物化视图的数据仍会保留。</strong></p>
<p>物化视图本质是一张特殊的数据表，例如使用<code>SHOW TABLE</code>查看数据表的列表：</p>
<pre><code class="language-sql">SHOW TABLES
┌───────name────────┐
│ .inner.view_test2 │
│ .inner.view_test3 │
└───────────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表的操作"><a class="header" href="#表的操作">表的操作</a></h1>
<p>目前只有<code>MergeTree</code>、<code>Merge</code>和<code>Distributed</code>这三类表引擎支持<code>ALTER</code>查询.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="追加字段"><a class="header" href="#追加字段">追加字段</a></h1>
<p>假如需要对一张数据表追加新的字段，可以使用如下语法：</p>
<pre><code class="language-sql">ALTER TABLE tb_name ADD COLUMN [IF NOT EXISTS] name [type] [default_expr] [AFTER name_after]
</code></pre>
<p>例如，在数据表的末尾增加新字段：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 ADD COLUMN OS String DEFAULT 'mac'
</code></pre>
<p>或是通过<code>AFTER</code>修饰符，在指定字段的后面增加新字段：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 ADD COLUMN IP String AFTER ID
</code></pre>
<p>对于数据表中已经存在的旧数据而言，新追加的字段会使用默认值补全。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="修改数据类型"><a class="header" href="#修改数据类型">修改数据类型</a></h1>
<p>如果需要改变表字段的数据类型或者默认值，需要使用下面的语法：</p>
<pre><code class="language-sql">ALTER TABLE tb_name MODIFY COLUMN [IF EXISTS] name [type] [default_expr]
</code></pre>
<p>修改某个字段的数据类型，实质上会调用相应的toType转型方法。如果当前的类型与期望的类型不能兼容，则修改操作将会失败。</p>
<p>例如，将String类型的IP字段修改为IPv4类型是可行的：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 MODIFY COLUMN IP IPv4
</code></pre>
<p>而尝试将String类型转为UInt类型就会出现错误：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 MODIFY COLUMN OS UInt32
DB::Exception: Cannot parse string 'mac' as UInt32: syntax error at begin of string.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="修改备注"><a class="header" href="#修改备注">修改备注</a></h1>
<p>做好信息备注是保持良好编程习惯的美德之一。追加备注的语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE tb_name COMMENT COLUMN [IF EXISTS] name 'some comment'
</code></pre>
<p>例如，为ID字段增加备注：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 COMMENT COLUMN ID '主键ID'
</code></pre>
<p>使用DESC查询可以看到上述增加备注的操作已经生效：</p>
<pre><code class="language-sql">DESC testcol_v1
┌─name────────┬─type───┬─comment─┐
│ ID          │ String │ 主键ID   │
└─────────────┴────────┴─────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="删除已有字段"><a class="header" href="#删除已有字段">删除已有字段</a></h1>
<p>假如要删除某个字段，可以使用下面的语句：</p>
<pre><code class="language-sql">ALTER TABLE tb_name DROP COLUMN [IF EXISTS] name
</code></pre>
<p>例如，执行下面的语句删除URL字段：</p>
<pre><code class="language-sql">ALTER TABLE testcol_v1 DROP COLUMN URL
</code></pre>
<p>上述列字段在被删除之后，它的数据也会被连带删除。进一步来到testcol_v1的数据目录查验，会发现URL的数据文件已经被删除了：</p>
<pre><code class="language-sql"># pwd
/chbase/data/data/default/testcol_v1/201907_2_2_0
# ll
total 56
-rw-r-----. 1 clickhouse clickhouse  28 Jul  2 21:02 EventTime.bin
-rw-r-----. 1 clickhouse clickhouse  30 Jul  2 21:02 ID.bin
-rw-r-----. 1 clickhouse clickhouse  30 Jul  2 21:02 IP.bin
-rw-r-----. 1 clickhouse clickhouse  30 Jul  2 21:02 OS.bin
省略…
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="移动数据表"><a class="header" href="#移动数据表">移动数据表</a></h1>
<p>原文参考: <a href="https://clickhouse.com/docs/zh/sql-reference/statements/rename/">RENAME语法</a></p>
<p>在Linux系统中，<code>mv</code>命令的本意是将一个文件从原始位置A移动到目标位置B，但是如果位置A与位置B相同，则可以变相实现重命名的作用。</p>
<p>ClickHouse的<code>RENAME</code>查询就与之有着异曲同工之妙，<code>RENAME语句</code>的完整语法如下所示：</p>
<pre><code class="language-sql">RENAME TABLE [db_name11.]tb_name11 TO [db_name12.]tb_name12, [db_name21.]tb_name21 TO [db_name22.]tb_name22, ...
</code></pre>
<p>RENAME可以修改数据表的名称，如果将原始数据库与目标数据库设为不同的名称，那么就可以实现数据表在两个数据库之间移动的效果。</p>
<p>例如在下面的例子中，<code>testcol_v1</code>从<code>default</code>默认数据库被移动到了<code>db_test</code>数据库，同时数据表被重命名为<code>testcol_v2</code>：</p>
<pre><code class="language-sql">RENAME TABLE default.testcol_v1 TO db_test.testcol_v2
</code></pre>
<p>需要注意的是，数据表的移动只能在单个节点的范围内。</p>
<p>换言之，数据表移动的目标数据库和原始数据库必须处在同一个服务节点内，而不能是集群中的远程节点。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="清空数据表"><a class="header" href="#清空数据表">清空数据表</a></h1>
<p>假设需要将表内的数据全部清空，而不是直接删除这张表，则可以使用<code>TRUNCATE</code>语句，它的完整语法如下所示：</p>
<pre><code class="language-sql">TRUNCATE TABLE [IF EXISTS] [db_name.]tb_name
</code></pre>
<p>例如执行下面的语句，就能将<code>db_test.testcol_v2</code>的数据一次性清空：</p>
<pre><code class="language-sql">TRUNCATE TABLE db_test.testcol_v2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据分区操作"><a class="header" href="#数据分区操作">数据分区操作</a></h1>
<p>了解并善用数据分区益处颇多，熟练掌握它的使用方法，可以为后续的程序设计带来极大的灵活性和便利性，目前只有<code>MergeTree</code>系列的表引擎支持数据分区。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询分区信息"><a class="header" href="#查询分区信息">查询分区信息</a></h1>
<p><code>ClickHouse</code>内置了许多<code>system系统表</code>，用于查询自身的状态信息。</p>
<p>其中<code>parts系统表</code>专门用于查询数据表的分区信息。</p>
<p>例如执行下面的语句，就能够得到数据表<code>partition_v2</code>的分区状况：</p>
<pre><code class="language-sql">SELECT partition_id,name,table,database FROM system.parts WHERE table = 'partition_v2'
┌─partition_id───┬─name───────────┬────table─────┬─database┐
│ 201905         │ 201905_1_1_0_6 │ partition_v2 │ default │
│ 201910         │ 201910_3_3_0_6 │ partition_v2 │ default │
│ 201911         │ 201911_4_4_0_6 │ partition_v2 │ default │
│ 201912         │ 201912_5_5_0_6 │ partition_v2 │ default │
└────────────────┴────────────────┴──────────────┴─────────┘
</code></pre>
<p>如上所示，目前<code>partition_v2</code>共拥有4个分区，其中<code>partition_id</code>或者<code>name</code>等同于分区的主键，可以基于它们的取值确定一个具体的分区。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="删除指定分区"><a class="header" href="#删除指定分区">删除指定分区</a></h1>
<p>合理地设计分区键并利用分区的删除功能，就能够达到数据更新的目的。删除一个指定分区的语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE tb_name DROP PARTITION partition_expr
</code></pre>
<p>假如现在需要更新partition_v2数据表整个7月份的数据，则可以先将7月份的分区删除：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 DROP PARTITION 201907
</code></pre>
<p>然后将整个7月份的新数据重新写入，就可以达到更新的目的：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 VALUES ('A004-update','www.bruce.com', '2019-07-02'),…
</code></pre>
<p>查验数据表，可以看到7月份的数据已然更新：</p>
<pre><code class="language-sql">SELECT * from partition_v2 ORDER BY EventTime
┌─ID───────────┬──────URL──────┬ EventTime  ┐
│ A001         │ www.nauu.com  │ 2019-05-02 │
│ A002         │ www.nauu1.com │ 2019-06-02 │
│ A004-update  │ www.bruce.com │ 2019-07-02 │
└──────────────┴───────────────┴────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="复制分区数据"><a class="header" href="#复制分区数据">复制分区数据</a></h1>
<p>ClickHouse支持将A表的分区数据复制到B表，这项特性可以用于快速数据写入、多表间数据同步和备份等场景，它的完整语法如下：</p>
<pre><code class="language-sql">ALTER TABLE B REPLACE PARTITION partition_expr FROM A
</code></pre>
<p>不过需要注意的是，并不是任意数据表之间都能够相互复制，它们还需要满足两个前提条件：</p>
<ul>
<li>两张表需要拥有相同的分区键；</li>
<li>它们的表结构完全相同。</li>
</ul>
<p>再执行下面的语句：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 REPLACE PARTITION 201908 FROM partition_v1
</code></pre>
<p>即能够将partition_v1的整个201908分区中的数据复制到partition_v2：</p>
<pre><code class="language-sql">SELECT * from partition_v2 ORDER BY EventTime
┌─────ID───────┬─────URL───────┬──EventTime─┐
│ A000         │ www.nauu.com  │ 2019-05-01 │
│ A001         │ www.nauu.com  │ 2019-05-02 │
省略…
│ A004-update  │ www.bruce.com │ 2019-07-02 │
│ A006-v1      │ www.v1.com    │ 2019-08-05 │
│ A007-v1      │ www.v1.com    │ 2019-08-20 │
└──────────────┴───────────────┴────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重置分区数据"><a class="header" href="#重置分区数据">重置分区数据</a></h1>
<p>如果数据表某一列的数据有误，需要将其重置为初始值，此时可以使用下面的语句实现：</p>
<pre><code class="language-sql">ALTER TABLE tb_name CLEAR COLUMN column_name IN PARTITION partition_expr
</code></pre>
<p>对于默认值的含义，笔者遵循如下原则：如果声明了默认值表达式，则以表达式为准；否则以相应数据类型的默认值为准。</p>
<p>例如，执行下面的语句会重置partition_v2表内201908分区的URL数据重置。</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 CLEAR COLUMN URL in PARTITION 201908
</code></pre>
<p>查验数据后会发现，URL字段已成功被全部重置为空字符串了（String类型的默认值）。</p>
<pre><code class="language-sql">SELECT * from partition_v2
┌───ID────┬─URL──┬───EventTime┐
│ A006-v1 │      │ 2019-08-05 │
│ A007-v1 │      │ 2019-08-20 │
└─────────┴──────┴────────────┘
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="卸载与装载分区"><a class="header" href="#卸载与装载分区">卸载与装载分区</a></h1>
<p>表分区可以通过<code>DETACH</code>语句卸载，分区被卸载后，它的物理数据并没有删除，而是被转移到了当前数据表目录的<code>detached</code>子目录下。而装载分区则是反向操作，它能够将<code>detached</code>子目录下的某个分区重新装载回去。卸载与装载这一对伴生的操作，常用于分区数据的迁移和备份场景。卸载某个分区的语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE tb_name DETACH PARTITION partition_expr
</code></pre>
<p>例如，执行下面的语句能够将partition_v2表内整个8月份的分区卸载：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 DETACH PARTITION 201908
</code></pre>
<p>此时再次查询这张表，会发现其中2019年8月份的数据已经没有了。而进入partition_v2的磁盘目录，则可以看到被卸载的分区目录已经被移动到了detached目录中：</p>
<pre><code class="language-sql"># pwd
/chbase/data/data/default/partition_v2/detached
# ll
total 4
drwxr-x---. 2 clickhouse clickhouse 4096 Aug 31 23:16 201908_4_4_0
</code></pre>
<p>记住，一旦分区被移动到了detached子目录，就代表它已经脱离了ClickHouse的管理，ClickHouse并不会主动清理这些文件。这些分区文件会一直存在，除非我们主动删除或者使用ATTACH语句重新装载它们。装载某个分区的完整语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE tb_name ATTACH PARTITION partition_expr
</code></pre>
<p>再次执行下面的语句，就可以将刚才已被卸载的201908分区重新装载回去：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 ATTACH PARTITION 201908
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/op_partition_backup.html#%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%E5%88%86%E5%8C%BA">备份与还原分区</a>
<ul>
<li><a href="clickhouse/op_partition_backup.html#%E5%AF%BC%E5%87%BA%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD">导出文件备份</a></li>
<li><a href="clickhouse/op_partition_backup.html#%E9%80%9A%E8%BF%87%E5%BF%AB%E7%85%A7%E8%A1%A8%E5%A4%87%E4%BB%BD">通过快照表备份</a></li>
<li><a href="clickhouse/op_partition_backup.html#%E6%8C%89%E5%88%86%E5%8C%BA%E5%A4%87%E4%BB%BD">按分区备份</a>
<ul>
<li><a href="clickhouse/op_partition_backup.html#%E4%BD%BF%E7%94%A8freeze%E5%A4%87%E4%BB%BD">使用FREEZE备份</a></li>
<li><a href="clickhouse/op_partition_backup.html#%E4%BD%BF%E7%94%A8fetch%E5%A4%87%E4%BB%BD">使用FETCH备份</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="备份与还原分区"><a class="header" href="#备份与还原分区">备份与还原分区</a></h1>
<p>ClickHouse自身提供了多种备份数据的方法，根据数据规模的不同，可以选择不同的形式。</p>
<h2 id="导出文件备份"><a class="header" href="#导出文件备份">导出文件备份</a></h2>
<p>如果数据的体量较小，可以通过dump的形式将数据导出为本地文件。例如执行下面的语句将test_backup的数据导出：</p>
<pre><code class="language-shell">&gt; clickhouse-client --query=&quot;SELECT * FROM test_backup&quot; &gt; /chbase/test_backup.tsv
</code></pre>
<p>将备份数据再次<code>导恢复数据</code>，则可以执行下面的语句：</p>
<pre><code class="language-sql">&gt; cat /chbase/test_backup.tsv | clickhouse-client --query &quot;INSERT INTO test_backup FORMAT TSV&quot;
</code></pre>
<p>上述这种dump形式的优势在于，可以利用SELECT查询并筛选数据，然后按需备份。如果是备份整个表的数据，也可以直接复制它的整个目录文件，例如：</p>
<pre><code class="language-sql">&gt; mkdir -p /chbase/backup/default/ &amp; cp -r /chbase/data/default/test_backup /chbase/backup/default/
</code></pre>
<h2 id="通过快照表备份"><a class="header" href="#通过快照表备份">通过快照表备份</a></h2>
<p>快照表实质上就是普通的数据表，它通常按照业务规定的备份频率创建，例如按天或者按周创建。</p>
<p>所以首先需要建立一张与原表结构相同的数据表，然后再使用INSERT INTO SELECT句式，点对点地将数据从原表写入备份表。</p>
<p>假设数据表<code>test_backup</code>需要按日进行备份，现在为它创建当天的备份表：</p>
<pre><code class="language-sql">CREATE TABLE test_backup_0206 AS test_backup
</code></pre>
<p>有了备份表之后，就可以点对点地备份数据了，例如：</p>
<pre><code class="language-sql">INSERT INTO TABLE test_backup_0206 SELECT * FROM test_backup
</code></pre>
<p>如果考虑到容灾问题，也可以将备份表放置在不同的ClickHouse节点上，此时需要将上述SQL语句改成远程查询的形式：</p>
<pre><code class="language-sql">INSERT INTO TABLE test_backup_0206 SELECT * FROM remote('ch5.nauu.com:9000', 'default', 'test_backup', 'default')
</code></pre>
<h2 id="按分区备份"><a class="header" href="#按分区备份">按分区备份</a></h2>
<p>基于数据分区的备份，ClickHouse目前提供了<code>FREEZE</code>与<code>FETCH</code>两种方式，现在分别介绍它们的使用方法。</p>
<h3 id="使用freeze备份"><a class="header" href="#使用freeze备份">使用FREEZE备份</a></h3>
<p>FREEZE的完整语法如下所示：</p>
<p>参考原文: <a href="https://clickhouse.com/docs/zh/sql-reference/statements/alter/#alter_freeze-partition">https://clickhouse.com/docs/zh/sql-reference/statements/alter/#alter_freeze-partition</a></p>
<pre><code class="language-sql">ALTER TABLE tb_name FREEZE PARTITION partition_expr
</code></pre>
<p>分区在被备份之后，会被统一保存到ClickHouse根路径/shadow/N子目录下。</p>
<p>其中，N是一个自增长的整数，它的含义是备份的次数（FREEZE执行过多少次），具体次数由shadow子目录下的increment.txt文件记录。</p>
<p>而分区备份实质上是对原始目录文件进行硬链接操作，所以并不会导致额外的存储空间。整个备份的目录会一直向上追溯至data根路径的整个链路：</p>
<pre><code class="language-shell">/data/[database]/[table]/[partition_folder]
</code></pre>
<p>例如执行下面的语句，会对数据表partition_v2的201908分区进行备份：</p>
<pre><code class="language-sql">:) ALTER TABLE partition_v2 FREEZE PARTITION 201908
</code></pre>
<p>进入shadow子目录，即能够看到刚才备份的分区目录：</p>
<pre><code class="language-shell"># pwd
/chbase/data/shadow/1/data/default/partition_v2
# ll
total 4
drwxr-x---. 2 clickhouse clickhouse 4096 Sep  1 00:22 201908_5_5_0
</code></pre>
<p><strong>对于备份分区的还原操作，则需要借助ATTACH装载分区的方式来实现。</strong></p>
<p><strong>这意味着如果要还原数据，首先需要主动将shadow子目录下的分区文件复制到相应数据表的detached目录下，然后再使用ATTACH语句装载。</strong></p>
<h3 id="使用fetch备份"><a class="header" href="#使用fetch备份">使用FETCH备份</a></h3>
<p>FETCH只支持ReplicatedMergeTree系列的表引擎，它的完整语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE tb_name FETCH PARTITION partition_id FROM zk_path
</code></pre>
<p>其工作原理与<code>ReplicatedMergeTree</code>同步数据的原理类似，FETCH通过指定的<code>zk_path</code>找到<code>ReplicatedMergeTree</code>的所有副本实例，然后从中选择一个最合适的副本，并下载相应的分区数据。例如执行下面的语句：</p>
<pre><code class="language-sql">ALTER TABLE test_fetch FETCH PARTITION 2019 FROM '/clickhouse/tables/01/test_fetch'
</code></pre>
<p>表示指定将test_fetch的2019分区下载到本地，并保存到对应数据表的detached目录下，目录如下所示：</p>
<pre><code class="language-sql">data/default/test_fetch/detached/2019_0_0_0
</code></pre>
<p>与FREEZE一样，对于备份分区的还原操作，也需要借助ATTACH装载分区来实现。</p>
<p>FREEZE和FETCH虽然都能实现对分区文件的备份，但是它们并不会备份数据表的元数据。</p>
<p>所以说如果想做到万无一失的备份，还需要对数据表的元数据进行备份，它们是<code>/data/metadata</code>目录下的<code>[table].sql</code>文件。目前这些元数据需要用户通过复制的形式单独备份。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式ddl执行"><a class="header" href="#分布式ddl执行">分布式DDL执行</a></h1>
<p>ClickHouse支持集群模式，一个集群拥有1到多个节点。</p>
<p>CREATE、ALTER、DROP、RENMAE及TRUNCATE这些DDL语句，都支持分布式执行。</p>
<p>这意味着，如果在集群中任意一个节点上执行DDL语句，那么集群中的每个节点都会以相同的顺序执行相同的语句。</p>
<p>这项特性意义非凡，它就如同批处理命令一样，省去了需要依次去单个节点执行DDL的烦恼。</p>
<p>将一条普通的DDL语句转换成分布式执行十分简单，只需加上<code>ON CLUSTER cluster_name</code>声明即可。</p>
<p>例如，执行下面的语句后将会对<code>ch_cluster</code>集群内的所有节点广播这条DDL语句：</p>
<pre><code class="language-sql">CREATE TABLE partition_v3 ON CLUSTER ch_cluster( 
  ID String,
  URL String,
  EventTime Date
) ENGINE =  MergeTree()
PARTITION BY toYYYYMM(EventTime)
ORDER BY ID
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="clickhouse/insert_data.html#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5">数据的写入</a>
<ul>
<li><a href="clickhouse/insert_data.html#%E4%BD%BF%E7%94%A8values%E6%A0%BC%E5%BC%8F">使用VALUES格式</a></li>
<li><a href="clickhouse/insert_data.html#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E6%A0%BC%E5%BC%8F">使用指定格式</a></li>
<li><a href="clickhouse/insert_data.html#%E4%BD%BF%E7%94%A8select%E5%AD%90%E5%8F%A5%E5%BD%A2%E5%BC%8F">使用SELECT子句形式</a></li>
</ul>
</li>
</ul>
<h1 id="数据的写入"><a class="header" href="#数据的写入">数据的写入</a></h1>
<p>参考原文: <a href="https://clickhouse.com/docs/zh/sql-reference/statements/insert-into/">INSERT INTO 语句</a></p>
<p>INSERT语句支持三种语法范式，三种范式各有不同，可以根据写入的需求灵活运用。</p>
<h2 id="使用values格式"><a class="header" href="#使用values格式">使用VALUES格式</a></h2>
<p>语法:</p>
<pre><code class="language-sql">INSERT INTO [db.]table [(c1, c2, c3…)] VALUES (v11, v12, v13…), (v21, v22, v23…), ...
</code></pre>
<p>其中，c1、c2、c3是列字段声明，可省略。</p>
<p>VALUES后紧跟的是由元组组成的待写入数据，通过下标位与列字段声明一一对应。</p>
<p>数据支持批量声明写入，多行数据之间使用逗号分隔。</p>
<p>例如执行下面的语句，将批量写入多条数据：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 VALUES 
('A0011','www.nauu.com', '2019-10-01'), 
('A0012','www.nauu.com', '2019-11-20'),
('A0013','www.nauu.com', '2019-12-20')
</code></pre>
<p>在使用VALUES格式的语法写入数据时，支持加入表达式或函数，例如：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 VALUES ('A0014',toString(1+2), now())
</code></pre>
<h2 id="使用指定格式"><a class="header" href="#使用指定格式">使用指定格式</a></h2>
<p>语法:</p>
<pre><code class="language-sql">INSERT INTO [db.]table [(c1, c2, c3…)] FORMAT format_name data_set
</code></pre>
<p>ClickHouse支持多种数据格式（更多格式可参见官方手册），以常用的CSV格式写入为例：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 FORMAT CSV \
'A0017','www.nauu.com', '2019-10-01' \
'A0018','www.nauu.com', '2019-10-01'
</code></pre>
<h2 id="使用select子句形式"><a class="header" href="#使用select子句形式">使用SELECT子句形式</a></h2>
<p>语法：</p>
<pre><code class="language-sql">INSERT INTO [db.]table [(c1, c2, c3…)] SELECT ...
</code></pre>
<p>通过SELECT子句可将查询结果写入数据表，假设需要将partition_v1的数据写入partition_v2，则可以使用下面的语句：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 SELECT * FROM partition_v1
</code></pre>
<p>在通过SELECT子句写入数据的时候，同样也支持加入表达式或函数，例如：</p>
<pre><code class="language-sql">INSERT INTO partition_v2 SELECT 'A0020', 'www.jack.com', now()
</code></pre>
<p>虽然VALUES和SELECT子句的形式都支持声明表达式或函数，但是表达式和函数会带来额外的性能开销，从而导致写入性能的下降。</p>
<p>所以如果追求极致的写入性能，就应该尽可能避免使用它们。</p>
<p>ClickHouse内部所有的数据操作都是面向Block数据块的，所以INSERT查询最终会将数据转换为Block数据块。也正因如此，INSERT语句在单个数据块的写入过程中是具有原子性的。</p>
<p>在默认的情况下，每个数据块最多可以写入<code>1048576</code>行数据（由<code>max_insert_block_size</code>参数控制）。也就是说，如果一条<code>INSERT语句</code>写入的数据少于<code>max_insert_block_size</code>行，那么这批数据的写入是具有原子性的，即要么全部成功，要么全部失败。</p>
<blockquote>
<p><strong>注意</strong>:</p>
<p>只有在ClickHouse服务端处理数据的时候才具有这种原子写入的特性。</p>
<p>例如使用JDBC或者HTTP接口时。因为<code>max_insert_block_size</code>参数在使用<code>CLI命令行</code>或者<code>INSERT SELECT</code>子句写入时是不生效的。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据的删除与修改"><a class="header" href="#数据的删除与修改">数据的删除与修改</a></h1>
<p>ClickHouse提供了<code>DELETE</code>和<code>UPDATE</code>的能力，这类操作被称为<code>Mutation</code>查询，它可以看作<code>ALTER</code>语句的变种。</p>
<p>虽然<code>Mutation</code>能最终实现修改和删除，但不能完全以通常意义上的<code>UPDATE</code>和<code>DELETE</code>来理解，我们必须清醒地认识到它的不同：</p>
<ul>
<li>
<p>首先，<code>Mutation语句</code>是一种 <strong>“很重”</strong> 的操作，更适用于批量数据的修改和删除；</p>
</li>
<li>
<p>其次，它不支持事务，一旦语句被提交执行，就会立刻对现有数据产生影响，无法回滚；</p>
</li>
<li>
<p>最后，<code>Mutation语句</code>的执行是一个异步的后台过程，语句被提交之后就会立即返回。</p>
</li>
<li>
<p>所以这并不代表具体逻辑已经执行完毕，它的具体执行进度需要通过<code>system.mutations</code>系统表查询。</p>
</li>
</ul>
<h2 id="数据删除"><a class="header" href="#数据删除">数据删除</a></h2>
<p>DELETE语句的完整语法如下所示:</p>
<pre><code class="language-sql">ALTER TABLE [db_name.]table_name DELETE WHERE filter_expr
</code></pre>
<p>数据删除的范围由WHERE查询子句决定。例如，执行下面语句可以删除partition_v2表内所有ID等于A003的数据：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 DELETE WHERE ID = 'A003'
</code></pre>
<p>由于演示的数据很少，DELETE操作给人的感觉和常用的OLTP数据库无异。但是我们心中应该要明白这是一个异步的后台执行动作。</p>
<p>再次进入数据目录，让我们看看删除操作是如何实现的：</p>
<pre><code class="language-shell"># pwd
/chbase/data/data/default/partition_v2
# ll
total 52
drwxr-x---. 2 clickhouse clickhouse 4096 Jul  6 15:03 201905_1_1_0
drwxr-x---. 2 clickhouse clickhouse 4096 Jul  6 15:03 201905_1_1_0_6
省略…
drwxr-x---. 2 clickhouse clickhouse 4096 Jul  6 15:03 201909_5_5_0
drwxr-x---. 2 clickhouse clickhouse 4096 Jul  6 15:03 201909_5_5_0_6
drwxr-x---. 2 clickhouse clickhouse 4096 Jul  6 15:02 detached
-rw-r-----. 1 clickhouse clickhouse    1 Jul  6 15:02 format_version.txt
-rw-r-----. 1 clickhouse clickhouse   89 Jul  6 15:03 mutation_6.txt
</code></pre>
<p>可以发现，在执行了DELETE操作之后数据目录发生了一些变化。每一个原有的数据目录都额外增加了一个同名目录，并且在末尾处增加了_6的后缀。此外，目录下还多了一个名为mutation_6.txt的文件，mutation_6.txt文件的内容如下所示：</p>
<pre><code class="language-shell"># cat mutation_6.txt
format version: 1
create time: 2019-07-06 15:03:27
commands: DELETE WHERE ID = \'A003\'
</code></pre>
<p>原来mutation_6.txt是一个日志文件，它完整地记录了这次DELETE操作的执行语句和时间，而文件名的后缀_6与新增目录的后缀对应。那么后缀的数字从何而来呢？继续查询system.mutations系统表，一探究竟：</p>
<pre><code class="language-sql">SELECT database, table ,mutation_id, block_numbers.number as num ,is_done FROM system.mutations

┌─database──┬────table─────┬──mutation_id───┬───num──┬─is_done─┐
│ default   │ partition_v2 │ mutation_6.txt │ [6]    │ 1       │
└───────────┴──────────────┴────────────────┴────────┴─────────┘
</code></pre>
<p>至此，整个Mutation操作的逻辑就比较清晰了。</p>
<ul>
<li>每执行一条ALTER DELETE语句，都会在mutations系统表中生成一条对应的执行计划，当is_done等于1时表示执行完毕。</li>
<li>与此同时，在数据表的根目录下，会以mutation_id为名生成与之对应的日志文件用于记录相关信息。</li>
<li>而数据删除的过程是以数据表的每个分区目录为单位，将所有目录重写为新的目录，新目录的命名规则是在原有名称上加上<code>system.mutations.block_numbers.number</code>。</li>
</ul>
<p>数据在重写的过程中会将需要删除的数据去掉。旧的数据目录并不会立即删除，而是会被标记成非激活状态（active为0）。
等到MergeTree引擎的下一次合并动作触发时，这些非激活目录才会被真正从物理意义上删除。</p>
<h2 id="数据修改"><a class="header" href="#数据修改">数据修改</a></h2>
<p>数据修改除了需要指定具体的列字段之外，整个逻辑与数据删除别无二致，它的完整语法如下所示：</p>
<pre><code class="language-sql">ALTER TABLE [db_name.]table_name UPDATE column1 = expr1 [, ...] WHERE filter_expr
</code></pre>
<p>UPDATE支持在一条语句中同时定义多个修改字段，分区键和主键不能作为修改字段。例如，执行下面的语句即能够根据WHERE条件同时修改partition_v2内的URL和OS字段：</p>
<pre><code class="language-sql">ALTER TABLE partition_v2 
UPDATE URL = 'www.wayne.com', OS = 'mac' 
WHERE ID IN (
    SELECT ID 
    FROM partition_v2 
    WHERE EventTime = '2019-06-01'
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用语句"><a class="header" href="#常用语句">常用语句</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询数据大小"><a class="header" href="#查询数据大小">查询数据大小</a></h1>
<h2 id="mysql-1"><a class="header" href="#mysql-1">MYSQL</a></h2>
<pre><code class="language-sql">select
 table_schema as '数据库',
 table_name as '表名',
 table_rows as '记录数',
 truncate(data_length / 1024 / 1024, 2) as '数据容量(MB)',
 truncate(index_length / 1024 / 1024, 2) as '索引容量(MB)'
from
 information_schema.tables
order by
 data_length desc,
 index_length desc;
</code></pre>
<h2 id="clickhouse-1"><a class="header" href="#clickhouse-1">ClickHouse</a></h2>
<h3 id="查看数据库容量行数压缩率"><a class="header" href="#查看数据库容量行数压缩率">查看数据库容量、行数、压缩率</a></h3>
<pre><code class="language-sql">SELECT 
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌────总行数─┬─原始大小──┬─压缩大小─┬─压缩率─┐
│ 326819026 │ 77.15 GiB │ 5.75 GiB │      7 │
└───────────┴───────────┴──────────┴────────┘

1 rows in set. Elapsed: 0.047 sec. Processed 1.04 thousand rows, 520.93 KB (21.95 thousand
rows/s., 11.02 MB/s.) 
</code></pre>
<h3 id="查看数据表容量行数压缩率"><a class="header" href="#查看数据表容量行数压缩率">查看数据表容量、行数、压缩率</a></h3>
<pre><code class="language-sql">SELECT 
    table AS `表名`,
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
WHERE table IN ('temp_1')
GROUP BY table
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─表名───┬──总行数─┬─原始大小───┬─压缩大小──┬─压缩率─┐
│ temp_1 │ 3127523 │ 838.21 MiB │ 60.04 MiB │      7 │
└────────┴─────────┴────────────┴───────────┴────────┘

1 rows in set. Elapsed: 0.008 sec.
</code></pre>
<h3 id="查看数据表分区信息"><a class="header" href="#查看数据表分区信息">查看数据表分区信息</a></h3>
<pre><code class="language-sql">--查看测试表在19年12月的分区信息
SELECT 
    partition AS `分区`,
    sum(rows) AS `总行数`,
    formatReadableSize(sum(data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(data_compressed_bytes)) AS `压缩大小`,
    round((sum(data_compressed_bytes) / sum(data_uncompressed_bytes)) * 100, 0) AS `压缩率`
FROM system.parts
WHERE (database IN ('default')) AND (table IN ('temp_1')) AND (partition LIKE '2019-12-%')
GROUP BY partition
ORDER BY partition ASC
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─分区───────┬─总行数─┬─原始大小──┬─压缩大小───┬─压缩率─┐
│ 2019-12-01 │     24 │ 6.17 KiB  │ 2.51 KiB   │     41 │
│ 2019-12-02 │   9215 │ 2.45 MiB  │ 209.74 KiB │      8 │
│ 2019-12-03 │  17265 │ 4.46 MiB  │ 453.78 KiB │     10 │
│ 2019-12-04 │  27741 │ 7.34 MiB  │ 677.25 KiB │      9 │
│ 2019-12-05 │  31500 │ 8.98 MiB  │ 469.30 KiB │      5 │
│ 2019-12-06 │    157 │ 37.50 KiB │ 4.95 KiB   │     13 │
│ 2019-12-07 │    110 │ 32.75 KiB │ 3.86 KiB   │     12 │
└────────────┴────────┴───────────┴────────────┴────────┘

7 rows in set. Elapsed: 0.005 sec. 
</code></pre>
<h3 id="查看数据表字段的信息"><a class="header" href="#查看数据表字段的信息">查看数据表字段的信息</a></h3>
<pre><code class="language-sql">SELECT 
    column AS `字段名`,
    any(type) AS `类型`,
    formatReadableSize(sum(column_data_uncompressed_bytes)) AS `原始大小`,
    formatReadableSize(sum(column_data_compressed_bytes)) AS `压缩大小`,
    sum(rows) AS `行数`
FROM system.parts_columns
WHERE (database = 'default') AND (table = 'temp_1')
GROUP BY column
ORDER BY column ASC
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">┌─字段名───────────┬─类型─────┬─原始大小───┬─压缩大小───┬────行数─┐
│ a                │ String   │ 23.83 MiB  │ 134.13 KiB │ 3127523 │
│ b                │ String   │ 19.02 MiB  │ 127.72 KiB │ 3127523 │
│ c                │ String   │ 5.97 MiB   │ 49.09 KiB  │ 3127523 │
│ d             │ String   │ 3.95 MiB   │ 532.86 KiB │ 3127523 │
│ e                │ String   │ 5.17 MiB   │ 49.47 KiB  │ 3127523 │
│ totalDate        │ DateTime │ 11.93 MiB  │ 1.26 MiB   │ 3127523 │
└──────────────────┴──────────┴────────────┴────────────┴─────────┘
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
